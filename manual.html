<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作業書作成支援ツール</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect x='8' y='8' width='48' height='48' rx='8' fill='%234f46e5'/%3E%3Cpath d='M26 22 L26 42 L44 32 Z' fill='%23ffffff'/%3E%3C/svg%3E">

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* 画面全体のレイアウト */
        body, html {
            height: 100%;
            overflow: hidden; /* 全体スクロールを禁止 */
        }

        /* --- 印刷用スタイル --- */
        @media print {
            body, html {
                height: auto;
                overflow: visible;
                background: white; 
            }
            
            .print-hidden { display: none !important; }
            .print-block { display: block !important; }

            .scroll-area {
                height: auto !important;
                overflow: visible !important;
                background: white !important;
                padding: 0 !important;
            }

            .a4-preview {
                width: 100% !important;
                max-width: none !important;
                box-shadow: none !important;
                margin: 0 !important;
                padding: 0 !important;
                background: white !important;
                min-height: 0 !important;
                background-image: none !important;
            }
            
            .step-item {
                break-inside: avoid;
                page-break-inside: avoid;
                border: 1px solid #ddd !important;
                margin-bottom: 15px !important;
                padding: 10px !important;
                height: auto;
                display: flex !important;
                page-break-after: auto;
            }

            .step-image-mask {
                overflow: hidden !important; 
            }
            .step-toolbar {
                display: none !important;
            }

            textarea { 
                border: none !important; 
                resize: none !important;
                padding: 0 !important;
                overflow: visible !important;
            }
            textarea::-webkit-resizer {
                display: none !important;
            }
            
            .lg\:col-span-8 {
                width: 100% !important;
                grid-column: span 12 / span 12 !important;
            }
        }

        /* カスタムスクロールバー */
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        textarea.resize-vertical {
            resize: vertical !important;
            min-height: 100px;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 font-sans">
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // --- Icons ---
        const IconBase = ({ children, size = 18, className = "", ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>
                {children}
            </svg>
        );

        const Camera = (props) => (<IconBase {...props}><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path><circle cx="12" cy="13" r="3"></circle></IconBase>);
        const FileVideo = (props) => (<IconBase {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="m10 11 5 3-5 3v-6z"></path></IconBase>);
        const FileImage = (props) => (<IconBase {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></IconBase>);
        const Trash2 = (props) => (<IconBase {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></IconBase>);
        const Printer = (props) => (<IconBase {...props}><polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect></IconBase>);
        const FileText = (props) => (<IconBase {...props}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></IconBase>);
        const Save = (props) => (<IconBase {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></IconBase>);
        const Upload = (props) => (<IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></IconBase>);
        const ArrowUp = (props) => (<IconBase {...props}><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></IconBase>);
        const ArrowDown = (props) => (<IconBase {...props}><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></IconBase>);
        const RotateCw = (props) => (<IconBase {...props}><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></IconBase>);
        const ZoomIn = (props) => (<IconBase {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></IconBase>);
        const ZoomOut = (props) => (<IconBase {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></IconBase>);
        const RefreshCcw = (props) => (<IconBase {...props}><polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></IconBase>);
        const LayoutRow = (props) => (<IconBase {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></IconBase>);
        const LayoutCol = (props) => (<IconBase {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="12" x2="21" y2="12"></line></IconBase>);
        const ArrowRight = (props) => (<IconBase {...props}><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></IconBase>);
        const Circle = (props) => (<IconBase {...props}><circle cx="12" cy="12" r="10"></circle></IconBase>);
        const PlusCircle = (props) => (<IconBase {...props}><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></IconBase>);
        const Type = (props) => (<IconBase {...props}><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></IconBase>);
        const Hash = (props) => (<IconBase {...props}><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></IconBase>);

        // --- Main Component ---
        function App() {
            const [videoSrc, setVideoSrc] = useState(null);
            const [steps, setSteps] = useState([]);
            const [fileName, setFileName] = useState("");
            const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
            
            const [dragState, setDragState] = useState({ isDragging: false, stepIndex: null, startX: 0, startY: 0, initialImgX: 0, initialImgY: 0 });
            const [splitDragState, setSplitDragState] = useState({ isDragging: false, stepIndex: null, startX: 0, startY: 0, containerWidth: 0, containerHeight: 0, initialRatio: 0.5, initialHeight: 400, type: 'row' });
            
            const [annotationTool, setAnnotationTool] = useState(null);
            const [selectedAnnotation, setSelectedAnnotation] = useState(null); 
            const [handleDragState, setHandleDragState] = useState(null); 

            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const fileInputRef = useRef(null);
            const imageInputRef = useRef(null); // 画像用
            const jsonInputRef = useRef(null);
            const stepsEndRef = useRef(null);
            const scrollAreaRef = useRef(null);

            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    if (hasUnsavedChanges && steps.length > 0) {
                        e.preventDefault(); e.returnValue = ''; 
                    }
                };
                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [hasUnsavedChanges, steps]);

            // --- 画像ドラッグ ---
            const handleImageMouseDown = (index, e) => {
                if (annotationTool || selectedAnnotation) {
                    if (selectedAnnotation) setSelectedAnnotation(null);
                    return; 
                }
                e.preventDefault(); 
                setDragState({ isDragging: true, stepIndex: index, startX: e.clientX, startY: e.clientY, initialImgX: steps[index].x || 0, initialImgY: steps[index].y || 0 });
            };

            const handleImageMouseMove = (e) => {
                if (!dragState.isDragging || dragState.stepIndex === null) return;
                e.preventDefault();
                const deltaX = e.clientX - dragState.startX;
                const deltaY = e.clientY - dragState.startY;
                setSteps(prev => {
                    const next = [...prev];
                    next[dragState.stepIndex].x = dragState.initialImgX + deltaX;
                    next[dragState.stepIndex].y = dragState.initialImgY + deltaY;
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const handleImageMouseUp = () => {
                if (dragState.isDragging) setDragState({ isDragging: false, stepIndex: null, startX: 0, startY: 0, initialImgX: 0, initialImgY: 0 });
            };

            // --- 分割バードラッグ ---
            const handleSplitMouseDown = (index, e, containerRef, type) => {
                e.preventDefault(); e.stopPropagation();
                const container = containerRef.current;
                if (container) {
                    setSplitDragState({ isDragging: true, stepIndex: index, startX: e.clientX, startY: e.clientY, containerWidth: container.offsetWidth, containerHeight: container.offsetHeight, initialRatio: steps[index].splitRatio || 0.5, initialHeight: steps[index].imageHeight || 400, type: type });
                }
            };
            const handleSplitMouseMove = (e) => {
                if (!splitDragState.isDragging || splitDragState.stepIndex === null) return;
                e.preventDefault();
                setSteps(prev => {
                    const next = [...prev];
                    if (splitDragState.type === 'row') {
                        const deltaX = e.clientX - splitDragState.startX;
                        const newRatio = Math.max(0.2, Math.min(0.8, splitDragState.initialRatio + (deltaX / splitDragState.containerWidth)));
                        next[splitDragState.stepIndex].splitRatio = newRatio;
                    } else {
                        const deltaY = e.clientY - splitDragState.startY;
                        next[splitDragState.stepIndex].imageHeight = Math.max(100, Math.min(1000, splitDragState.initialHeight + deltaY));
                    }
                    return next;
                });
                setHasUnsavedChanges(true);
            };
            const handleSplitMouseUp = () => {
                if (splitDragState.isDragging) setSplitDragState(prev => ({ ...prev, isDragging: false, stepIndex: null }));
            };

            // --- 注釈ハンドル操作 ---
            const handleHandleMouseDown = (e, type, stepIndex, annId) => {
                e.preventDefault(); e.stopPropagation();
                const container = e.target.closest('.step-image-mask');
                if (!container) return;
                const rect = container.getBoundingClientRect();
                const ann = steps[stepIndex].annotations.find(a => a.id === annId);
                if(!ann) return;

                setHandleDragState({
                    isDragging: true,
                    type: type, 
                    stepIndex,
                    annotationId: annId,
                    startX: e.clientX,
                    startY: e.clientY,
                    rect: rect,
                    initialAnn: JSON.parse(JSON.stringify(ann))
                });
            };

            const handleHandleMouseMove = (e) => {
                if (!handleDragState || !handleDragState.isDragging) return;
                e.preventDefault();
                const { type, stepIndex, annotationId, startX, startY, rect, initialAnn } = handleDragState;

                const deltaXPx = e.clientX - startX;
                const deltaYPx = e.clientY - startY;
                const deltaX = (deltaXPx / rect.width) * 100;
                const deltaY = (deltaYPx / rect.height) * 100;

                setSteps(prev => {
                    const next = [...prev];
                    const ann = next[stepIndex].annotations.find(a => a.id === annotationId);
                    if (!ann) return next;

                    if (type === 'move') {
                         ann.x = initialAnn.x + deltaX;
                         ann.y = initialAnn.y + deltaY;
                    } else if (type === 'resize-circle-w') {
                        // 横幅変更 (rx)
                        ann.rx = Math.max(1, initialAnn.rx + (deltaX / 2));
                    } else if (type === 'resize-circle-h') {
                        // 縦幅変更 (ry)
                        ann.ry = Math.max(1, initialAnn.ry + (deltaY / 2));
                    } else if (type === 'resize-text-label') {
                        // テキストラベルのフォントサイズ変更
                        ann.fontSize = Math.max(1, Math.min(10, initialAnn.fontSize + (deltaY / 10)));
                    } else if (type === 'resize-number-stamp') {
                        // 番号スタンプのサイズ変更
                        const avgDelta = (deltaX + deltaY) / 2;
                        ann.stampSize = Math.max(2, Math.min(15, initialAnn.stampSize + (avgDelta / 10)));
                    } else if (type === 'arrow-start' || type === 'arrow-end') {
                        const rad = initialAnn.rotation * Math.PI / 180;
                        const halfLen = initialAnn.length / 2;
                        let startX = initialAnn.x - halfLen * Math.cos(rad);
                        let startY = initialAnn.y - halfLen * Math.sin(rad);
                        let endX = initialAnn.x + halfLen * Math.cos(rad);
                        let endY = initialAnn.y + halfLen * Math.sin(rad);

                        if (type === 'arrow-start') {
                            startX += deltaX;
                            startY += deltaY;
                        } else {
                            endX += deltaX;
                            endY += deltaY;
                        }

                        const newCenterX = (startX + endX) / 2;
                        const newCenterY = (startY + endY) / 2;
                        const dx = endX - startX;
                        const dy = endY - startY;
                        const newLength = Math.sqrt(dx*dx + dy*dy);
                        const newRad = Math.atan2(dy, dx);

                        ann.x = newCenterX;
                        ann.y = newCenterY;
                        ann.length = newLength;
                        ann.rotation = newRad * 180 / Math.PI;
                    }

                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const handleHandleMouseUp = () => {
                if (handleDragState) setHandleDragState(null);
            };

            // Global Mouse Events
            useEffect(() => {
                const handleMove = (e) => {
                    handleImageMouseMove(e);
                    handleSplitMouseMove(e);
                    handleHandleMouseMove(e);
                };
                const handleUp = () => {
                    handleImageMouseUp();
                    handleSplitMouseUp();
                    handleHandleMouseUp();
                };
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
                return () => {
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                };
            }, [dragState, splitDragState, handleDragState]);

            // 注釈追加
            const addAnnotation = (stepIndex, type, x, y, containerRef) => {
                if (!annotationTool || !containerRef.current) return;
                const container = containerRef.current;
                const rect = container.getBoundingClientRect();
                const relativeX = ((x - rect.left) / rect.width) * 100;
                const relativeY = ((y - rect.top) / rect.height) * 100;

                // 円の初期サイズ計算 (見た目上の正円)
                const aspect = rect.width / rect.height;
                const initialRx = 5; // 横幅の5%
                const initialRy = 5 * aspect; // 縦幅の5% * アスペクト比

                // 番号スタンプの場合、既存の最大番号+1を自動設定
                let nextNumber = 1;
                if (type === 'number-stamp') {
                    const existingNumbers = (steps[stepIndex].annotations || [])
                        .filter(a => a.type === 'number-stamp')
                        .map(a => a.number || 1);
                    if (existingNumbers.length > 0) {
                        nextNumber = Math.max(...existingNumbers) + 1;
                    }
                }

                const newAnnotation = {
                    id: Date.now(),
                    type: type,
                    x: relativeX,
                    y: relativeY,
                    rx: initialRx, // 横半径
                    ry: initialRy, // 縦半径
                    size: 1.0, // 後方互換用(使わない)
                    rotation: 0,
                    length: 16,
                    strokeWidth: 2,
                    // テキストラベル用
                    text: type === 'text-label' ? 'テキスト' : undefined,
                    fontSize: type === 'text-label' ? 3 : undefined,
                    // 番号スタンプ用
                    number: type === 'number-stamp' ? nextNumber : undefined,
                    stampSize: type === 'number-stamp' ? 6 : undefined,
                };
                setSteps(prev => {
                    const newSteps = [...prev];
                    if (!newSteps[stepIndex].annotations) newSteps[stepIndex].annotations = [];
                    newSteps[stepIndex].annotations.push(newAnnotation);
                    return newSteps;
                });
                setHasUnsavedChanges(true);
                setAnnotationTool(null);
                setSelectedAnnotation({ stepIndex, annotationId: newAnnotation.id });
            };

            const deleteAnnotation = (stepIndex, annotationId) => {
                setSteps(prev => {
                    const newSteps = [...prev];
                    if (newSteps[stepIndex].annotations) {
                        newSteps[stepIndex].annotations = newSteps[stepIndex].annotations.filter(a => a.id !== annotationId);
                    }
                    return newSteps;
                });
                setSelectedAnnotation(null);
                setHasUnsavedChanges(true);
            };
            
            const changeStrokeWidth = (stepIndex, annotationId, delta) => {
                setSteps(prev => {
                    const next = [...prev];
                    const ann = next[stepIndex].annotations.find(a => a.id === annotationId);
                    if (ann) ann.strokeWidth = Math.max(0.5, Math.min(10, (ann.strokeWidth || 2) + delta));
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const editAnnotationText = (stepIndex, annotationId) => {
                const ann = steps[stepIndex].annotations.find(a => a.id === annotationId);
                if (!ann) return;

                if (ann.type === 'text-label') {
                    const newText = prompt('テキストを入力してください:', ann.text || '');
                    if (newText !== null) {
                        setSteps(prev => {
                            const next = [...prev];
                            const a = next[stepIndex].annotations.find(a => a.id === annotationId);
                            if (a) a.text = newText;
                            return next;
                        });
                        setHasUnsavedChanges(true);
                    }
                } else if (ann.type === 'number-stamp') {
                    const newNumber = prompt('番号を入力してください:', ann.number || 1);
                    if (newNumber !== null && !isNaN(newNumber)) {
                        setSteps(prev => {
                            const next = [...prev];
                            const a = next[stepIndex].annotations.find(a => a.id === annotationId);
                            if (a) a.number = parseInt(newNumber);
                            return next;
                        });
                        setHasUnsavedChanges(true);
                    }
                }
            };

            // 動画・キャプチャ・画像アップロード処理
            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file) setVideoSrc(URL.createObjectURL(file));
            };

            // --- 画像アップロード処理 ---
            const handleImageFiles = (e) => {
                const files = e.target.files;
                if (!files || files.length === 0) return;

                const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
                if (imageFiles.length === 0) return;

                let loadedCount = 0;
                const newSteps = [];

                imageFiles.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        newSteps.push({
                            id: Date.now() + Math.random(),
                            originalImage: ev.target.result,
                            image: ev.target.result,
                            text: ``,
                            scale: 1, x: 0, y: 0, layout: 'row', splitRatio: 0.5, imageHeight: 400, annotations: []
                        });
                        loadedCount++;
                        if (loadedCount === imageFiles.length) {
                            setSteps(prev => [...prev, ...newSteps]);
                            setHasUnsavedChanges(true);
                            setTimeout(() => {
                                if (stepsEndRef.current) {
                                    stepsEndRef.current.scrollIntoView({ behavior: "smooth", block: "nearest" });
                                }
                            }, 100);
                        }
                    };
                    reader.readAsDataURL(file);
                });
                e.target.value = '';
            };

            const captureFrame = () => {
                if (videoRef.current && canvasRef.current) {
                    const video = videoRef.current;
                    const canvas = canvasRef.current;
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const dataUrl = canvas.toDataURL('image/jpeg');
                    const newStep = {
                        id: Date.now(),
                        originalImage: dataUrl,
                        image: dataUrl,
                        text: ``,
                        scale: 1, x: 0, y: 0, layout: 'row', splitRatio: 0.5, imageHeight: 400, annotations: []
                    };
                    setSteps([...steps, newStep]);
                    setHasUnsavedChanges(true);
                    
                    // キャプチャ時のみ一番下にスクロール
                    setTimeout(() => {
                        if (stepsEndRef.current) {
                            stepsEndRef.current.scrollIntoView({ behavior: "smooth", block: "nearest" });
                        }
                    }, 100);
                }
            };

            const handleTextChange = (index, value) => {
                setSteps(prev => {
                    const next = [...prev];
                    next[index].text = value;
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const deleteStep = (index) => {
                setSteps(prev => prev.filter((_, i) => i !== index));
                setHasUnsavedChanges(true);
            };

            const moveStep = (index, direction) => {
                if ((direction === -1 && index === 0) || (direction === 1 && index === steps.length - 1)) return;
                setSteps(prev => {
                    const next = [...prev];
                    const temp = next[index];
                    next[index] = next[index + direction];
                    next[index + direction] = temp;
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const toggleLayout = (index) => {
                setSteps(prev => {
                    const next = [...prev];
                    const current = next[index].layout || 'row';
                    next[index].layout = current === 'row' ? 'col' : 'row';
                    if (next[index].layout === 'row') next[index].splitRatio = 0.5;
                    else next[index].imageHeight = 400;
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const rotateImage = (index) => {
                const step = steps[index];
                const img = new Image();
                img.src = step.image;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.height;
                    canvas.height = img.width;
                    const ctx = canvas.getContext('2d');
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(90 * Math.PI / 180);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    const newDataUrl = canvas.toDataURL('image/jpeg');
                    setSteps(prev => {
                        const next = [...prev];
                        const curScale = next[index].scale || 1;
                        next[index].image = newDataUrl;
                        next[index].x = 0; next[index].y = 0; 
                        next[index].scale = curScale; 
                        return next;
                    });
                    setHasUnsavedChanges(true);
                };
            };

            const zoomImage = (index, delta) => {
                setSteps(prev => {
                    const next = [...prev];
                    let s = (next[index].scale || 1) + delta;
                    if (s < 0.5) s = 0.5; if (s > 5.0) s = 5.0;
                    next[index].scale = s;
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const resetImage = (index) => {
                setSteps(prev => {
                    const next = [...prev];
                    if(next[index].originalImage) next[index].image = next[index].originalImage; 
                    next[index].scale = 1; next[index].x = 0; next[index].y = 0;
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            // データ保存・読込
            const saveData = () => {
                if (steps.length === 0) return alert("データがありません");
                const data = JSON.stringify({ steps, fileName });
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${fileName.trim() || "作業書データ"}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                setHasUnsavedChanges(false);
            };

            const loadData = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        if (Array.isArray(data)) {
                            if (hasUnsavedChanges && steps.length > 0 && !confirm("上書きしますか？")) return;
                            const fixed = data.map(s => ({ ...s, originalImage: s.originalImage || s.image }));
                            setSteps(fixed.map(fixStepData));
                        } else if (data.steps) {
                            if (hasUnsavedChanges && steps.length > 0 && !confirm("上書きしますか？")) return;
                            const fixed = data.steps.map(s => ({ ...s, originalImage: s.originalImage || s.image }));
                            setSteps(fixed.map(fixStepData));
                            if(data.fileName) setFileName(data.fileName);
                        }
                        setHasUnsavedChanges(false);
                    } catch (err) { alert("読み込み失敗"); }
                };
                reader.readAsText(file);
                e.target.value = '';
            };

            const fixStepData = (step) => ({
                ...step,
                splitRatio: step.splitRatio || 0.5,
                imageHeight: step.imageHeight || 400,
                annotations: (step.annotations || []).map(a => {
                    // 旧データ(size)があればrx,ryに変換する簡易ロジック
                    const baseSize = (a.size || 1.0) * 5;
                    return {
                        ...a,
                        rx: a.rx || baseSize,
                        ry: a.ry || baseSize,
                        rotation: a.rotation || 0,
                        length: a.length || 16,
                        strokeWidth: a.strokeWidth || 2,
                        // テキストラベル用のデフォルト値
                        text: a.type === 'text-label' ? (a.text || 'テキスト') : a.text,
                        fontSize: a.type === 'text-label' ? (a.fontSize || 3) : a.fontSize,
                        // 番号スタンプ用のデフォルト値
                        number: a.type === 'number-stamp' ? (a.number || 1) : a.number,
                        stampSize: a.type === 'number-stamp' ? (a.stampSize || 6) : a.stampSize,
                    };
                })
            });

            return (
                <div className="h-full flex flex-col font-sans text-gray-800 bg-gray-50 overflow-hidden">
                    <header className="flex-shrink-0 flex items-center justify-between border-b bg-white px-6 py-3 shadow-sm z-50 print-hidden">
                        <div><h1 className="text-xl font-bold flex items-center gap-2 text-indigo-600"><FileVideo className="w-6 h-6" /> 作業書作成支援ツール</h1></div>
                        <div className="flex items-center gap-4">
                            <div className="flex items-center gap-2 bg-gray-100 rounded-lg p-1">
                                <span className="text-xs font-bold text-gray-500 ml-2">名:</span>
                                <input type="text" value={fileName} onChange={(e) => setFileName(e.target.value)} className="border rounded px-2 py-1 text-sm w-32 focus:outline-none" placeholder="作業書データ" />
                                <div className="h-5 w-px bg-gray-300 mx-1"></div>
                                <button onClick={saveData} disabled={steps.length === 0} className={`flex items-center gap-1 px-3 py-1.5 rounded text-sm transition-colors ${hasUnsavedChanges && steps.length > 0 ? "bg-indigo-100 text-indigo-700 font-bold" : "bg-white text-gray-700 hover:bg-gray-50"}`}><Save className="w-4 h-4" /> 保存{hasUnsavedChanges ? "*" : ""}</button>
                                <button onClick={() => jsonInputRef.current?.click()} className="flex items-center gap-1 px-3 py-1.5 bg-white text-gray-700 rounded text-sm hover:bg-gray-50"><Upload className="w-4 h-4" /> 読込</button>
                                <input type="file" accept=".json" ref={jsonInputRef} className="hidden" onChange={loadData} />
                            </div>
                            <button onClick={() => window.print()} className="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 text-sm shadow-md"><Printer className="w-4 h-4" /> 印刷 / PDF</button>
                        </div>
                    </header>

                    <div className="flex-1 flex overflow-hidden">
                        <div className="w-1/3 min-w-[320px] max-w-[480px] bg-white border-r p-4 overflow-y-auto print-hidden z-40 shadow-md">
                            <div className="sticky top-0 bg-white pb-4 z-10">
                                <h2 className="font-semibold mb-4 flex items-center gap-2 text-gray-700"><FileVideo className="w-5 h-5 text-indigo-500" /> ソース動画</h2>
                                {!videoSrc ? (
                                    <div onClick={() => fileInputRef.current?.click()} className="border-2 border-dashed border-gray-300 rounded-lg h-48 flex flex-col items-center justify-center cursor-pointer hover:bg-gray-50 transition-colors">
                                        <FileVideo className="w-10 h-10 text-gray-300 mb-2" /><p className="text-gray-500 font-medium text-sm">動画を選択</p>
                                    </div>
                                ) : (
                                    <div className="space-y-3">
                                        <div className="rounded-lg overflow-hidden bg-black aspect-video shadow-sm"><video ref={videoRef} src={videoSrc} controls className="w-full h-full object-contain" /></div>
                                        <div className="flex gap-2">
                                            <button onClick={captureFrame} className="flex-1 flex items-center justify-center gap-2 bg-indigo-600 text-white py-2 rounded-lg hover:bg-indigo-700 font-medium shadow-sm active:scale-95 transition-transform"><Camera className="w-5 h-5" /> キャプチャ</button>
                                            <button onClick={() => setVideoSrc(null)} className="px-3 py-2 bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200" title="動画を変更"><Trash2 className="w-5 h-5" /></button>
                                        </div>
                                    </div>
                                )}
                                <input type="file" accept="video/*" ref={fileInputRef} className="hidden" onChange={handleFileUpload} />
                                <canvas ref={canvasRef} className="hidden" />

                                <div className="mt-6 border-t pt-4">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2 text-gray-700"><FileImage className="w-5 h-5 text-indigo-500" /> 画像を追加</h3>
                                    <button onClick={() => imageInputRef.current?.click()} className="w-full border-2 border-dashed border-gray-300 rounded-lg h-24 flex flex-col items-center justify-center cursor-pointer hover:bg-gray-50 transition-colors text-gray-500 hover:text-indigo-500">
                                        <PlusCircle className="w-8 h-8 mb-1" /><span className="text-xs">画像を選択 または ドロップ</span>
                                    </button>
                                    <input type="file" accept="image/*" multiple ref={imageInputRef} className="hidden" onChange={handleImageFiles} />
                                </div>
                            </div>
                            
                            <div className="mt-6 p-4 bg-blue-50 rounded-lg text-sm text-blue-800">
                                <p className="font-bold mb-1">使い方</p>
                                <ul className="list-decimal list-inside space-y-1 text-xs opacity-80">
                                    <li>動画を読み込み、再生位置で「キャプチャ」ボタンを押します。</li>
                                    <li>または「画像を追加」から写真などの画像ファイルを追加します。</li>
                                    <li>右側に作業項目が追加されます。</li>
                                    <li>画像の下のボタンで、注釈追加や画像の編集ができます。</li>
                                    <li>注釈は4種類：矢印、丸、テキストラベル、番号スタンプ</li>
                                    <li>注釈はドラッグで移動、選択して変形、太さ変更が可能です。</li>
                                    <li>テキストや番号は「編」ボタンで編集できます。</li>
                                    <li>テキスト欄の右下をドラッグして高さを自由に調整できます。</li>
                                </ul>
                            </div>
                        </div>

                        <div className="flex-1 bg-gray-200 overflow-y-auto scroll-area custom-scrollbar" ref={scrollAreaRef} onClick={() => setSelectedAnnotation(null)}>
                            {/* A4プレビュー枠を外し、通常のリスト表示に戻す */}
                            <div className="w-full max-w-5xl mx-auto my-8 p-4 right-content transition-all">
                                <div className="flex justify-between items-center mb-6 pb-2 print-hidden border-b border-gray-300">
                                    <h2 className="font-semibold flex items-center gap-2 text-lg text-gray-700"><FileText className="w-5 h-5 text-indigo-500" /> 作成された作業項目 ({steps.length})</h2>
                                </div>

                                {steps.length === 0 ? (
                                    <div className="flex flex-col items-center justify-center h-64 text-gray-400 print-hidden"><p>ここに作業項目が追加されます</p></div>
                                ) : (
                                    <div className="space-y-6 print:space-y-0 print:block">
                                        {steps.map((step, index) => {
                                            const isColLayout = step.layout === 'col';
                                            return (
                                                <div key={step.id} className={`group relative flex gap-6 p-4 rounded-xl border border-gray-300 hover:border-indigo-300 transition-all bg-white step-item ${isColLayout ? 'flex-col step-col' : 'flex-col md:flex-row step-row'}`}>
                                                    <div className={`flex flex-col ${isColLayout ? 'w-full' : ''}`} style={{ width: !isColLayout ? `${(step.splitRatio || 0.5) * 100}%` : '100%' }}>
                                                        <div className={`flex-shrink-0 step-image-mask relative cursor-move bg-gray-50 border border-gray-200`} style={{ overflow: 'hidden', height: isColLayout ? `${step.imageHeight || 400}px` : 'auto', maxHeight: isColLayout ? 'none' : '300px' }} onMouseDown={(e) => handleImageMouseDown(index, e)}>
                                                            <div className={`relative w-full h-full flex items-center justify-center ${!isColLayout ? 'aspect-video' : ''}`} style={{overflow: 'visible'}}>
                                                                <img src={step.image} className="max-w-none transition-transform duration-75 ease-out select-none pointer-events-none" style={{ transform: `translate(${step.x || 0}px, ${step.y || 0}px) scale(${step.scale || 1})`, height: isColLayout ? '100%' : 'auto', width: isColLayout ? 'auto' : '100%' }} draggable="false" />
                                                                <div className="absolute top-2 left-2 bg-black/60 text-white text-xs px-2 py-1 rounded font-mono z-10 pointer-events-none shadow-sm">Step {index + 1}</div>
                                                                <svg className="absolute w-full h-full pointer-events-none z-20" style={{ pointerEvents: annotationTool || selectedAnnotation ? 'auto' : 'none', overflow: 'hidden', top: 0, left: 0 }} viewBox="0 0 100 100" preserveAspectRatio="none">
                                                                    {(step.annotations || []).map((ann) => {
                                                                        const isSelected = selectedAnnotation && selectedAnnotation.stepIndex === index && selectedAnnotation.annotationId === ann.id;
                                                                        const strokeW = ann.strokeWidth || 2;
                                                                        const arrowLen = ann.length || 16;
                                                                        const rot = (ann.rotation || 0) * Math.PI / 180;
                                                                        
                                                                        let p1x, p1y, p2x, p2y;
                                                                        if (ann.type === 'arrow') {
                                                                            p1x = -arrowLen/2 * Math.cos(rot); p1y = -arrowLen/2 * Math.sin(rot);
                                                                            p2x = arrowLen/2 * Math.cos(rot); p2y = arrowLen/2 * Math.sin(rot);
                                                                        }

                                                                        return (
                                                                            <g key={ann.id} transform={`translate(${ann.x}, ${ann.y})`} className="pointer-events-auto" onClick={(e) => { e.stopPropagation(); setSelectedAnnotation({stepIndex: index, annotationId: ann.id}); }}>
                                                                                {/* ヒットエリア(透明な太い線/楕円) */}
                                                                                 {ann.type === 'arrow' && (
                                                                                     <line x1={p1x} y1={p1y} x2={p2x} y2={p2y} stroke="transparent" strokeWidth="20" />
                                                                                 )}
                                                                                 {ann.type === 'circle' && (
                                                                                     <ellipse cx="0" cy="0" rx={ann.rx} ry={ann.ry} stroke="transparent" strokeWidth="20" fill="none" />
                                                                                 )}
                                                                                 {ann.type === 'text-label' && (
                                                                                     <rect
                                                                                         x={-(ann.text || 'テキスト').length * (ann.fontSize || 3) * 0.3}
                                                                                         y={-(ann.fontSize || 3) * 0.6}
                                                                                         width={(ann.text || 'テキスト').length * (ann.fontSize || 3) * 0.6}
                                                                                         height={(ann.fontSize || 3) * 1.2}
                                                                                         fill="transparent"
                                                                                     />
                                                                                 )}
                                                                                 {ann.type === 'number-stamp' && (
                                                                                     <circle cx="0" cy="0" r={(ann.stampSize || 6) + 2} fill="transparent" />
                                                                                 )}

                                                                                {ann.type === 'arrow' && (
                                                                                    <>
                                                                                        <g>
                                                                                            <line x1={p1x} y1={p1y} x2={p2x - (2 + strokeW) * Math.cos(rot)} y2={p2y - (2 + strokeW) * Math.sin(rot)} stroke="#dc2626" strokeWidth={strokeW} strokeLinecap="round" />
                                                                                            {/* Arrow Head (Scales with stroke width) */}
                                                                                            <path d={`M ${p2x} ${p2y} L ${p2x - (6 + strokeW)*Math.cos(rot - 0.5)} ${p2y - (6 + strokeW)*Math.sin(rot - 0.5)} L ${p2x - (6 + strokeW)*Math.cos(rot + 0.5)} ${p2y - (6 + strokeW)*Math.sin(rot + 0.5)} Z`} fill="#dc2626" />
                                                                                        </g>
                                                                                        {isSelected && (
                                                                                            <>
                                                                                                <circle cx={p1x} cy={p1y} r="3" fill="#f59e0b" stroke="white" strokeWidth="1" className="cursor-move print-hidden" onMouseDown={(e) => handleHandleMouseDown(e, 'arrow-start', index, ann.id)} />
                                                                                                <circle cx={p2x} cy={p2y} r="3" fill="#f59e0b" stroke="white" strokeWidth="1" className="cursor-move print-hidden" onMouseDown={(e) => handleHandleMouseDown(e, 'arrow-end', index, ann.id)} />
                                                                                                <g transform={`translate(0, 10)`} className="print-hidden cursor-move" onMouseDown={(e) => handleHandleMouseDown(e, 'move', index, ann.id)}>
                                                                                                    <rect x="-10" y="-10" width="20" height="20" fill="transparent" />
                                                                                                </g>
                                                                                            </>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                                {ann.type === 'circle' && (
                                                                                    <>
                                                                                        <ellipse cx="0" cy="0" rx={ann.rx} ry={ann.ry} fill="none" stroke="#dc2626" strokeWidth={strokeW} />
                                                                                        {isSelected && (
                                                                                            <>
                                                                                                <rect x={-ann.rx} y={-ann.ry} width={ann.rx * 2} height={ann.ry * 2} fill="transparent" stroke="#3b82f6" strokeWidth="0.5" strokeDasharray="2 2" className="print-hidden" />
                                                                                                <circle cx={ann.rx} cy="0" r="3" fill="#3b82f6" stroke="white" strokeWidth="1" className="cursor-ew-resize print-hidden" onMouseDown={(e) => handleHandleMouseDown(e, 'resize-circle-w', index, ann.id)} />
                                                                                                <circle cx="0" cy={ann.ry} r="3" fill="#3b82f6" stroke="white" strokeWidth="1" className="cursor-ns-resize print-hidden" onMouseDown={(e) => handleHandleMouseDown(e, 'resize-circle-h', index, ann.id)} />
                                                                                                <g className="print-hidden cursor-move" onMouseDown={(e) => handleHandleMouseDown(e, 'move', index, ann.id)}>
                                                                                                    <circle cx="0" cy="0" r="5" fill="transparent" />
                                                                                                </g>
                                                                                            </>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                                {ann.type === 'text-label' && (
                                                                                    <>
                                                                                        {/* テキストラベル: 背景付きテキスト */}
                                                                                        <g>
                                                                                            {/* 背景測定用の非表示テキスト */}
                                                                                            <text x="0" y="0" fontSize={ann.fontSize || 3} fontWeight="bold" fill="transparent" textAnchor="middle" dominantBaseline="middle" id={`text-${ann.id}`}>
                                                                                                {ann.text || 'テキスト'}
                                                                                            </text>
                                                                                            {/* 背景矩形（おおよそのサイズ） */}
                                                                                            <rect
                                                                                                x={-(ann.text || 'テキスト').length * (ann.fontSize || 3) * 0.3}
                                                                                                y={-(ann.fontSize || 3) * 0.6}
                                                                                                width={(ann.text || 'テキスト').length * (ann.fontSize || 3) * 0.6}
                                                                                                height={(ann.fontSize || 3) * 1.2}
                                                                                                fill="#fef3c7"
                                                                                                stroke="#f59e0b"
                                                                                                strokeWidth="0.3"
                                                                                                rx="0.5"
                                                                                            />
                                                                                            {/* テキスト本体 */}
                                                                                            <text x="0" y="0" fontSize={ann.fontSize || 3} fontWeight="bold" fill="#92400e" textAnchor="middle" dominantBaseline="middle">
                                                                                                {ann.text || 'テキスト'}
                                                                                            </text>
                                                                                        </g>
                                                                                        {isSelected && (
                                                                                            <>
                                                                                                {/* 選択時のバウンディングボックス */}
                                                                                                <rect
                                                                                                    x={-(ann.text || 'テキスト').length * (ann.fontSize || 3) * 0.3}
                                                                                                    y={-(ann.fontSize || 3) * 0.6}
                                                                                                    width={(ann.text || 'テキスト').length * (ann.fontSize || 3) * 0.6}
                                                                                                    height={(ann.fontSize || 3) * 1.2}
                                                                                                    fill="transparent"
                                                                                                    stroke="#3b82f6"
                                                                                                    strokeWidth="0.3"
                                                                                                    strokeDasharray="1 1"
                                                                                                    className="print-hidden"
                                                                                                />
                                                                                                {/* リサイズハンドル（右下） */}
                                                                                                <circle
                                                                                                    cx={(ann.text || 'テキスト').length * (ann.fontSize || 3) * 0.3}
                                                                                                    cy={(ann.fontSize || 3) * 0.6}
                                                                                                    r="2"
                                                                                                    fill="#3b82f6"
                                                                                                    stroke="white"
                                                                                                    strokeWidth="0.5"
                                                                                                    className="cursor-nwse-resize print-hidden"
                                                                                                    onMouseDown={(e) => handleHandleMouseDown(e, 'resize-text-label', index, ann.id)}
                                                                                                />
                                                                                                {/* 移動ハンドル */}
                                                                                                <g className="print-hidden cursor-move" onMouseDown={(e) => handleHandleMouseDown(e, 'move', index, ann.id)}>
                                                                                                    <circle cx="0" cy="0" r="5" fill="transparent" />
                                                                                                </g>
                                                                                            </>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                                {ann.type === 'number-stamp' && (
                                                                                    <>
                                                                                        {/* 番号スタンプ: 円 + 番号 */}
                                                                                        <g>
                                                                                            <circle cx="0" cy="0" r={ann.stampSize || 6} fill="#ef4444" stroke="#991b1b" strokeWidth="0.5" />
                                                                                            <text x="0" y="0" fontSize={(ann.stampSize || 6) * 0.6} fontWeight="bold" fill="white" textAnchor="middle" dominantBaseline="middle">
                                                                                                {ann.number || 1}
                                                                                            </text>
                                                                                        </g>
                                                                                        {isSelected && (
                                                                                            <>
                                                                                                {/* 選択時のバウンディングボックス */}
                                                                                                <circle cx="0" cy="0" r={ann.stampSize || 6} fill="transparent" stroke="#3b82f6" strokeWidth="0.5" strokeDasharray="2 2" className="print-hidden" />
                                                                                                {/* リサイズハンドル（右） */}
                                                                                                <circle
                                                                                                    cx={ann.stampSize || 6}
                                                                                                    cy="0"
                                                                                                    r="2"
                                                                                                    fill="#3b82f6"
                                                                                                    stroke="white"
                                                                                                    strokeWidth="0.5"
                                                                                                    className="cursor-ew-resize print-hidden"
                                                                                                    onMouseDown={(e) => handleHandleMouseDown(e, 'resize-number-stamp', index, ann.id)}
                                                                                                />
                                                                                                {/* 移動ハンドル */}
                                                                                                <g className="print-hidden cursor-move" onMouseDown={(e) => handleHandleMouseDown(e, 'move', index, ann.id)}>
                                                                                                    <circle cx="0" cy="0" r="5" fill="transparent" />
                                                                                                </g>
                                                                                            </>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                            </g>
                                                                        );
                                                                    })}
                                                                </svg>
                                                            </div>
                                                            {annotationTool && <div className="absolute inset-0 cursor-crosshair z-20" onClick={(e) => { const containerRef = { current: e.currentTarget.parentElement }; addAnnotation(index, annotationTool, e.clientX, e.clientY, containerRef); }} />}
                                                        </div>

                                                        {/* Toolbar (Under Image - Horizontal) */}
                                                        <div 
                                                            className="flex flex-row items-center gap-2 mt-2 p-1.5 bg-gray-50 rounded border border-gray-200 print-hidden justify-center overflow-x-auto step-toolbar"
                                                            onClick={(e) => e.stopPropagation()}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                        >
                                                            <div className="flex gap-1 border-r pr-2 mr-1 border-gray-300">
                                                                <button onClick={() => setAnnotationTool(annotationTool === 'arrow' ? null : 'arrow')} className={`p-1.5 rounded ${annotationTool === 'arrow' ? 'bg-red-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-100 border border-gray-200'}`} title="矢印"><ArrowRight className="w-4 h-4" /></button>
                                                                <button onClick={() => setAnnotationTool(annotationTool === 'circle' ? null : 'circle')} className={`p-1.5 rounded ${annotationTool === 'circle' ? 'bg-red-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-100 border border-gray-200'}`} title="丸"><Circle className="w-4 h-4" /></button>
                                                                <button onClick={() => setAnnotationTool(annotationTool === 'text-label' ? null : 'text-label')} className={`p-1.5 rounded ${annotationTool === 'text-label' ? 'bg-red-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-100 border border-gray-200'}`} title="テキストラベル"><Type className="w-4 h-4" /></button>
                                                                <button onClick={() => setAnnotationTool(annotationTool === 'number-stamp' ? null : 'number-stamp')} className={`p-1.5 rounded ${annotationTool === 'number-stamp' ? 'bg-red-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-100 border border-gray-200'}`} title="番号スタンプ"><Hash className="w-4 h-4" /></button>
                                                            </div>

                                                            <div className="flex gap-1 border-r pr-2 mr-1 border-gray-300">
                                                                <button onClick={(e) => { e.stopPropagation(); selectedAnnotation && editAnnotationText(selectedAnnotation.stepIndex, selectedAnnotation.annotationId); }} disabled={!selectedAnnotation || !(steps[index].annotations?.find(a => a.id === selectedAnnotation?.annotationId)?.type === 'text-label' || steps[index].annotations?.find(a => a.id === selectedAnnotation?.annotationId)?.type === 'number-stamp')} className="p-1.5 bg-white text-gray-600 hover:text-indigo-600 hover:bg-indigo-50 rounded border border-gray-200 disabled:opacity-50" title="テキスト/番号を編集">編</button>
                                                                <button onClick={(e) => { e.stopPropagation(); selectedAnnotation && changeStrokeWidth(selectedAnnotation.stepIndex, selectedAnnotation.annotationId, 1); }} disabled={!selectedAnnotation} className="p-1.5 bg-white text-gray-600 hover:text-indigo-600 hover:bg-indigo-50 rounded border border-gray-200 disabled:opacity-50" title="線を太く">B+</button>
                                                                <button onClick={(e) => { e.stopPropagation(); selectedAnnotation && changeStrokeWidth(selectedAnnotation.stepIndex, selectedAnnotation.annotationId, -1); }} disabled={!selectedAnnotation} className="p-1.5 bg-white text-gray-600 hover:text-indigo-600 hover:bg-indigo-50 rounded border border-gray-200 disabled:opacity-50" title="線を細く">B-</button>
                                                                <button onClick={(e) => { e.stopPropagation(); selectedAnnotation && deleteAnnotation(selectedAnnotation.stepIndex, selectedAnnotation.annotationId); }} disabled={!selectedAnnotation} className="p-1.5 bg-white text-red-600 hover:bg-red-50 rounded border border-gray-200 disabled:opacity-50" title="削除"><Trash2 className="w-4 h-4" /></button>
                                                            </div>
                                                            
                                                            <div className="flex gap-1">
                                                                <button onClick={() => rotateImage(index)} className="p-1.5 bg-white text-gray-600 hover:text-indigo-600 hover:bg-indigo-50 rounded border border-gray-200" title="回転"><RotateCw className="w-4 h-4" /></button>
                                                                <button onClick={() => zoomImage(index, 0.1)} className="p-1.5 bg-white text-gray-600 hover:text-indigo-600 hover:bg-indigo-50 rounded border border-gray-200" title="拡大"><ZoomIn className="w-4 h-4" /></button>
                                                                <button onClick={() => zoomImage(index, -0.1)} className="p-1.5 bg-white text-gray-600 hover:text-indigo-600 hover:bg-indigo-50 rounded border border-gray-200" title="縮小"><ZoomOut className="w-4 h-4" /></button>
                                                                <button onClick={() => resetImage(index)} className="p-1.5 bg-white text-gray-600 hover:text-red-500 hover:bg-red-50 rounded border border-gray-200" title="リセット"><RefreshCcw className="w-4 h-4" /></button>
                                                            </div>
                                                        </div>
                                                    </div>

                                                    <div className={`bg-indigo-100 hover:bg-indigo-400 transition-colors flex-shrink-0 relative group print-hidden ${isColLayout ? 'h-3 w-full cursor-row-resize' : 'w-1.5 h-auto cursor-col-resize'}`} onMouseDown={(e) => { const container = e.currentTarget.closest('.step-item'); if (container) handleSplitMouseDown(index, e, { current: container }, isColLayout ? 'col' : 'row'); }}>
                                                        <div className={`absolute bg-gray-400/50 rounded-full ${isColLayout ? 'top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-8 h-1' : 'top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-1 h-8'}`}></div>
                                                    </div>

                                                    <div className={`flex flex-col gap-2 step-text-container ${isColLayout ? 'w-full' : ''}`} style={!isColLayout ? { width: `${(1 - (step.splitRatio || 0.5)) * 100}%` } : {}}>
                                                        <textarea value={step.text} onChange={(e) => handleTextChange(index, e.target.value)} className="w-full p-3 rounded-lg border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-100 outline-none resize-vertical text-gray-700 leading-relaxed shadow-inner" style={{ minHeight: '120px' }} placeholder="作業の手順やポイントを入力してください..." />
                                                    </div>

                                                    <div className="absolute -top-3 -right-3 flex gap-1 print-hidden z-40">
                                                        <button onClick={() => toggleLayout(index)} className={`bg-white border shadow-sm p-1.5 rounded-md transition-colors mr-2 ${isColLayout ? "text-indigo-600 border-indigo-200 bg-indigo-50" : "text-gray-500 hover:text-indigo-600"}`} title={isColLayout ? "横並びに戻す" : "画像を大きく表示（縦並び）"}>{isColLayout ? <LayoutRow className="w-4 h-4" /> : <LayoutCol className="w-4 h-4" />}</button>
                                                        <button onClick={() => moveStep(index, -1)} disabled={index === 0} className="bg-white text-gray-500 hover:text-indigo-600 border shadow-sm p-1.5 rounded-md disabled:opacity-30" title="上へ移動"><ArrowUp className="w-4 h-4" /></button>
                                                        <button onClick={() => moveStep(index, 1)} disabled={index === steps.length - 1} className="bg-white text-gray-500 hover:text-indigo-600 border shadow-sm p-1.5 rounded-md disabled:opacity-30" title="下へ移動"><ArrowDown className="w-4 h-4" /></button>
                                                        <button onClick={() => deleteStep(index)} className="bg-white text-gray-400 hover:text-red-500 border shadow-sm p-1.5 rounded-md" title="削除"><Trash2 className="w-4 h-4" /></button>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                        <div ref={stepsEndRef} />
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
