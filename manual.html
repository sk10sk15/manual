<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作業書作成支援ツール (動画版)</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect x='8' y='8' width='48' height='48' rx='8' fill='%234f46e5'/%3E%3Cpath d='M26 22 L26 42 L44 32 Z' fill='%23ffffff'/%3E%3C/svg%3E">

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* --- 印刷用スタイル --- */
        @media print {
            @page { 
                margin: 10mm;
                size: A4; 
            }
            body { 
                background: white; 
                -webkit-print-color-adjust: exact; 
                print-color-adjust: exact;
            }
            
            /* ヘッダーやボタンを隠す */
            .print-hidden { 
                display: none !important; 
            }

            .print-block { 
                display: block !important; 
            }
            
            /* 各ステップのスタイル調整 */
            .step-item {
                break-inside: avoid;
                page-break-inside: avoid;
                border: 1px solid #ddd !important;
                margin-bottom: 15px !important;
                padding: 10px !important;
                height: auto;
                display: flex !important;
                page-break-after: auto;
            }

            /* 横並び（デフォルト）時のスタイル */
            .step-row .step-image-container {
                max-height: 300px;
                /* widthはインラインスタイル（splitRatio）で制御されるため、固定値は設定しない */
                overflow: hidden !important;
            }
            /* .step-row .step-text-container のwidthはインラインスタイル（splitRatio）で制御されるため、固定値は設定しない */

            /* 縦並び（強調）時のスタイル */
            .step-col {
                flex-direction: column !important;
            }
            .step-col .step-image-container {
                max-height: 500px; /* 縦並び時は画像をより大きく許容 */
                width: 100% !important;
                overflow: hidden !important;
                margin-bottom: 10px;
            }
            .step-col .step-text-container {
                width: 100% !important;
            }

            textarea { 
                border: none !important; 
                resize: none !important; 
                padding: 0 !important;
                overflow: visible !important;
            }
            
            .main-content {
                padding: 0 !important;
                box-shadow: none !important;
            }
            
            .lg\:grid-cols-3 {
                display: block !important;
            }
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // --- Icons ---
        const IconBase = ({ children, size = 20, className = "", ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>
                {children}
            </svg>
        );

        const Camera = (props) => (<IconBase {...props}><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path><circle cx="12" cy="13" r="3"></circle></IconBase>);
        const FileVideo = (props) => (<IconBase {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="m10 11 5 3-5 3v-6z"></path></IconBase>);
        const Trash2 = (props) => (<IconBase {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></IconBase>);
        const Printer = (props) => (<IconBase {...props}><polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect></IconBase>);
        const FileText = (props) => (<IconBase {...props}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></IconBase>);
        const Save = (props) => (<IconBase {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></IconBase>);
        const Upload = (props) => (<IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></IconBase>);
        const ArrowUp = (props) => (<IconBase {...props}><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></IconBase>);
        const ArrowDown = (props) => (<IconBase {...props}><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></IconBase>);
        const RotateCw = (props) => (<IconBase {...props}><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></IconBase>);
        const ZoomIn = (props) => (<IconBase {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></IconBase>);
        const ZoomOut = (props) => (<IconBase {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></IconBase>);
        const RefreshCcw = (props) => (<IconBase {...props}><polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></IconBase>);
        const LayoutRow = (props) => (<IconBase {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></IconBase>);
        const LayoutCol = (props) => (<IconBase {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="12" x2="21" y2="12"></line></IconBase>);
        const ArrowRight = (props) => (<IconBase {...props}><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></IconBase>);
        const Circle = (props) => (<IconBase {...props}><circle cx="12" cy="12" r="10"></circle></IconBase>);
        const X = (props) => (<IconBase {...props}><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></IconBase>);

        // --- Main Component ---
        function App() {
            const [videoSrc, setVideoSrc] = useState(null);
            const [steps, setSteps] = useState([]);
            const [fileName, setFileName] = useState("");
            const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
            
            const [dragState, setDragState] = useState({
                isDragging: false,
                stepIndex: null,
                startX: 0,
                startY: 0,
                initialImgX: 0,
                initialImgY: 0
            });
            
            const [splitDragState, setSplitDragState] = useState({
                isDragging: false,
                stepIndex: null,
                startX: 0,
                containerWidth: 0,
                initialRatio: 0.5
            });
            
            const [annotationTool, setAnnotationTool] = useState(null); // 'arrow' | 'circle' | null
            const [hoveredAnnotation, setHoveredAnnotation] = useState(null); // {stepIndex, annotationId} | null
            const [annotationDragState, setAnnotationDragState] = useState({
                isDragging: false,
                stepIndex: null,
                annotationId: null,
                startX: 0,
                startY: 0,
                initialX: 0,
                initialY: 0
            });
            
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const fileInputRef = useRef(null);
            const jsonInputRef = useRef(null);

            // 未保存時の警告
            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    if (hasUnsavedChanges && steps.length > 0) {
                        e.preventDefault();
                        e.returnValue = ''; 
                    }
                };
                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [hasUnsavedChanges, steps]);

            // ドラッグ移動ハンドラ
            const handleImageMouseDown = (index, e) => {
                e.preventDefault(); 
                setDragState({
                    isDragging: true,
                    stepIndex: index,
                    startX: e.clientX,
                    startY: e.clientY,
                    initialImgX: steps[index].x || 0,
                    initialImgY: steps[index].y || 0
                });
            };

            const handleImageMouseMove = (e) => {
                if (!dragState.isDragging || dragState.stepIndex === null) return;
                
                e.preventDefault();
                const deltaX = e.clientX - dragState.startX;
                const deltaY = e.clientY - dragState.startY;
                
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    newSteps[dragState.stepIndex].x = dragState.initialImgX + deltaX;
                    newSteps[dragState.stepIndex].y = dragState.initialImgY + deltaY;
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            const handleImageMouseUp = () => {
                if (dragState.isDragging) {
                    setDragState({ isDragging: false, stepIndex: null, startX: 0, startY: 0, initialImgX: 0, initialImgY: 0 });
                }
            };

            useEffect(() => {
                window.addEventListener('mouseup', handleImageMouseUp);
                window.addEventListener('mousemove', handleImageMouseMove);
                return () => {
                    window.removeEventListener('mouseup', handleImageMouseUp);
                    window.removeEventListener('mousemove', handleImageMouseMove);
                };
            }, [dragState]);

            // 分割バーのドラッグハンドラ
            const handleSplitMouseDown = (index, e, containerRef) => {
                e.preventDefault();
                e.stopPropagation();
                const container = containerRef.current;
                if (container) {
                    setSplitDragState({
                        isDragging: true,
                        stepIndex: index,
                        startX: e.clientX,
                        containerWidth: container.offsetWidth,
                        initialRatio: steps[index].splitRatio || 0.5
                    });
                }
            };

            const handleSplitMouseMove = (e) => {
                if (!splitDragState.isDragging || splitDragState.stepIndex === null) return;
                
                e.preventDefault();
                const deltaX = e.clientX - splitDragState.startX;
                const newRatio = splitDragState.initialRatio + (deltaX / splitDragState.containerWidth);
                const clampedRatio = Math.max(0.2, Math.min(0.8, newRatio)); // 20%〜80%の範囲に制限
                
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    newSteps[splitDragState.stepIndex].splitRatio = clampedRatio;
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            const handleSplitMouseUp = () => {
                if (splitDragState.isDragging) {
                    setSplitDragState({ isDragging: false, stepIndex: null, startX: 0, containerWidth: 0, initialRatio: 0.5 });
                }
            };

            useEffect(() => {
                if (splitDragState.isDragging) {
                    window.addEventListener('mousemove', handleSplitMouseMove);
                    window.addEventListener('mouseup', handleSplitMouseUp);
                    return () => {
                        window.removeEventListener('mousemove', handleSplitMouseMove);
                        window.removeEventListener('mouseup', handleSplitMouseUp);
                    };
                }
            }, [splitDragState]);

            // 注釈の追加
            const addAnnotation = (stepIndex, type, x, y, containerRef) => {
                if (!annotationTool || !containerRef.current) return;
                
                const container = containerRef.current;
                const rect = container.getBoundingClientRect();
                const relativeX = ((x - rect.left) / rect.width) * 100;
                const relativeY = ((y - rect.top) / rect.height) * 100;
                
                const newAnnotation = {
                    id: Date.now(),
                    type: type, // 'arrow' or 'circle'
                    x: relativeX, // パーセンテージ
                    y: relativeY, // パーセンテージ
                    size: 1.0, // サイズ（デフォルト1.0）
                    rotation: 0, // 回転角度（度、矢印のみ）
                    length: 16, // 矢印の長さ（矢印のみ、デフォルト16）
                };
                
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    if (!newSteps[stepIndex].annotations) {
                        newSteps[stepIndex].annotations = [];
                    }
                    newSteps[stepIndex].annotations.push(newAnnotation);
                    return newSteps;
                });
                setHasUnsavedChanges(true);
                setAnnotationTool(null); // ツールをリセット
            };

            // 注釈の削除
            const deleteAnnotation = (stepIndex, annotationId) => {
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    if (newSteps[stepIndex].annotations) {
                        newSteps[stepIndex].annotations = newSteps[stepIndex].annotations.filter(
                            ann => ann.id !== annotationId
                        );
                    }
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            // 注釈のドラッグ開始
            const handleAnnotationMouseDown = (stepIndex, annotationId, e) => {
                e.preventDefault();
                e.stopPropagation();
                const annotation = steps[stepIndex].annotations.find(ann => ann.id === annotationId);
                if (!annotation) return;
                
                setAnnotationDragState({
                    isDragging: true,
                    stepIndex: stepIndex,
                    annotationId: annotationId,
                    startX: e.clientX,
                    startY: e.clientY,
                    initialX: annotation.x,
                    initialY: annotation.y
                });
            };

            // 注釈のドラッグ移動
            const handleAnnotationMouseMove = (e) => {
                if (!annotationDragState.isDragging || annotationDragState.stepIndex === null) return;
                
                e.preventDefault();
                const stepContainers = document.querySelectorAll('.step-image-container');
                const container = stepContainers[annotationDragState.stepIndex]?.querySelector('.relative');
                if (!container) return;
                
                const rect = container.getBoundingClientRect();
                const deltaX = e.clientX - annotationDragState.startX;
                const deltaY = e.clientY - annotationDragState.startY;
                
                // SVGのviewBoxが0-100なので、パーセンテージを直接計算
                const deltaXPercent = (deltaX / rect.width) * 100;
                const deltaYPercent = (deltaY / rect.height) * 100;
                
                const newX = Math.max(0, Math.min(100, annotationDragState.initialX + deltaXPercent));
                const newY = Math.max(0, Math.min(100, annotationDragState.initialY + deltaYPercent));
                
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    const annotation = newSteps[annotationDragState.stepIndex].annotations.find(
                        ann => ann.id === annotationDragState.annotationId
                    );
                    if (annotation) {
                        annotation.x = newX;
                        annotation.y = newY;
                    }
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            const handleAnnotationMouseUp = () => {
                if (annotationDragState.isDragging) {
                    setAnnotationDragState({ 
                        isDragging: false, 
                        stepIndex: null, 
                        annotationId: null, 
                        startX: 0, 
                        startY: 0, 
                        initialX: 0, 
                        initialY: 0 
                    });
                }
            };

            useEffect(() => {
                if (annotationDragState.isDragging) {
                    window.addEventListener('mousemove', handleAnnotationMouseMove);
                    window.addEventListener('mouseup', handleAnnotationMouseUp);
                    return () => {
                        window.removeEventListener('mousemove', handleAnnotationMouseMove);
                        window.removeEventListener('mouseup', handleAnnotationMouseUp);
                    };
                }
            }, [annotationDragState]);

            // 注釈のサイズ変更
            const resizeAnnotation = (stepIndex, annotationId, delta) => {
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    const annotation = newSteps[stepIndex].annotations.find(
                        ann => ann.id === annotationId
                    );
                    if (annotation) {
                        const currentSize = annotation.size || 1.0;
                        const newSize = Math.max(0.5, Math.min(3.0, currentSize + delta));
                        annotation.size = newSize;
                    }
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            // 矢印の回転
            const rotateAnnotation = (stepIndex, annotationId, delta) => {
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    const annotation = newSteps[stepIndex].annotations.find(
                        ann => ann.id === annotationId
                    );
                    if (annotation && annotation.type === 'arrow') {
                        const currentRotation = annotation.rotation || 0;
                        const newRotation = (currentRotation + delta) % 360;
                        annotation.rotation = newRotation < 0 ? newRotation + 360 : newRotation;
                    }
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            // 矢印の長さ変更
            const changeArrowLength = (stepIndex, annotationId, delta) => {
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    const annotation = newSteps[stepIndex].annotations.find(
                        ann => ann.id === annotationId
                    );
                    if (annotation && annotation.type === 'arrow') {
                        const currentLength = annotation.length || 16;
                        const newLength = Math.max(8, Math.min(40, currentLength + delta));
                        annotation.length = newLength;
                    }
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    setVideoSrc(url);
                }
            };

            const captureFrame = () => {
                if (videoRef.current && canvasRef.current) {
                    const video = videoRef.current;
                    const canvas = canvasRef.current;
                    
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    const dataUrl = canvas.toDataURL('image/jpeg');
                    
                    const newStep = {
                        id: Date.now(),
                        image: dataUrl,
                        text: ``,
                        scale: 1, 
                        x: 0, 
                        y: 0,
                        layout: 'row',
                        splitRatio: 0.5, // デフォルトは50:50
                        annotations: [], // 注釈配列
                    };
                    
                    setSteps([...steps, newStep]);
                    setHasUnsavedChanges(true);
                }
            };

            const handleTextChange = (index, value) => {
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    newSteps[index].text = value;
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            const deleteStep = (index) => {
                setSteps(prevSteps => prevSteps.filter((_, i) => i !== index));
                setHasUnsavedChanges(true);
            };

            const moveStep = (index, direction) => {
                if ((direction === -1 && index === 0) || (direction === 1 && index === steps.length - 1)) return;
                
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    const temp = newSteps[index];
                    newSteps[index] = newSteps[index + direction];
                    newSteps[index + direction] = temp;
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            const toggleLayout = (index) => {
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    const currentLayout = newSteps[index].layout || 'row';
                    newSteps[index].layout = currentLayout === 'row' ? 'col' : 'row';
                    // レイアウト切り替え時にsplitRatioをリセット（横並びに戻す時）
                    if (currentLayout === 'col') {
                        newSteps[index].splitRatio = 0.5;
                    }
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            const rotateImage = (index) => {
                const step = steps[index];
                const img = new Image();
                img.src = step.image;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.height;
                    canvas.height = img.width;
                    const ctx = canvas.getContext('2d');
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(90 * Math.PI / 180);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    const newDataUrl = canvas.toDataURL('image/jpeg');
                    setSteps(prevSteps => {
                        const newSteps = [...prevSteps];
                        newSteps[index].image = newDataUrl;
                        newSteps[index].x = 0;
                        newSteps[index].y = 0;
                        newSteps[index].scale = 1;
                        return newSteps;
                    });
                    setHasUnsavedChanges(true);
                };
            };

            const zoomImage = (index, delta) => {
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    const currentScale = newSteps[index].scale || 1;
                    let newScale = currentScale + delta;
                    if (newScale < 0.5) newScale = 0.5;
                    if (newScale > 5.0) newScale = 5.0;
                    newSteps[index].scale = newScale;
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            const resetImage = (index) => {
                setSteps(prevSteps => {
                    const newSteps = [...prevSteps];
                    newSteps[index].scale = 1;
                    newSteps[index].x = 0;
                    newSteps[index].y = 0;
                    return newSteps;
                });
                setHasUnsavedChanges(true);
            };

            // データ読み込み時にsplitRatioやannotationsが無い場合はデフォルト値を設定
            useEffect(() => {
                setSteps(prevSteps => {
                    return prevSteps.map(step => {
                        const updated = { ...step };
                        if (updated.splitRatio === undefined) {
                            updated.splitRatio = 0.5;
                        }
                        if (updated.annotations === undefined) {
                            updated.annotations = [];
                        } else {
                            // 既存の注釈にsize、rotation、lengthプロパティがない場合は追加
                            updated.annotations = updated.annotations.map(ann => {
                                const updatedAnn = { ...ann };
                                if (updatedAnn.size === undefined) {
                                    updatedAnn.size = 1.0;
                                }
                                if (updatedAnn.type === 'arrow') {
                                    if (updatedAnn.rotation === undefined) {
                                        updatedAnn.rotation = 0;
                                    }
                                    if (updatedAnn.length === undefined) {
                                        updatedAnn.length = 16;
                                    }
                                }
                                return updatedAnn;
                            });
                        }
                        return updated;
                    });
                });
            }, []);

            // --- データの保存 (JSON) ---
            const saveData = () => {
                if (steps.length === 0) {
                    alert("保存するデータがありません");
                    return;
                }
                const data = JSON.stringify(steps);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                const name = fileName.trim() || "作業書データ";
                link.download = `${name}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                setHasUnsavedChanges(false);
            };

            // --- データの読み込み (JSON) ---
            const loadData = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loadedSteps = JSON.parse(e.target.result);
                        if (Array.isArray(loadedSteps)) {
                            if (hasUnsavedChanges && steps.length > 0) {
                                if (!confirm("保存されていない変更があります。上書きしてデータを読み込みますか？")) return;
                            }
                            setSteps(loadedSteps);
                            setHasUnsavedChanges(false);
                        } else {
                            alert("ファイルの形式が正しくありません");
                        }
                    } catch (err) {
                        alert("ファイルの読み込みに失敗しました");
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            };

            const handlePrint = () => {
                window.print();
            };

            return (
                <div className="min-h-screen bg-gray-50 p-6 font-sans text-gray-800">
                    <div className="max-w-6xl mx-auto space-y-8">
                        
                        {/* Header */}
                        <header className="flex flex-col md:flex-row justify-between items-center border-b pb-4 bg-white p-6 rounded-xl shadow-sm gap-4 print-hidden">
                            <div>
                                <h1 className="text-2xl font-bold flex items-center gap-2 text-indigo-600">
                                    <FileVideo className="w-8 h-8" />
                                    作業書作成支援ツール (動画版)
                                </h1>
                                <p className="text-gray-500 text-sm mt-1">動画から画像を切り出し、説明を加えてPDFで出力します</p>
                            </div>
                            <div className="flex flex-wrap gap-2 justify-end items-center">
                                {/* 保存・読込ボタン群 */}
                                <div className="flex items-center gap-2 bg-gray-100 rounded-lg p-2">
                                    <div className="flex flex-col sm:flex-row items-center gap-1">
                                        <label className="text-xs font-bold text-gray-500 whitespace-nowrap">保存名:</label>
                                        <input 
                                            type="text" 
                                            value={fileName}
                                            onChange={(e) => setFileName(e.target.value)}
                                            className="border rounded px-2 py-1 text-sm w-32 focus:outline-none focus:ring-2 focus:ring-indigo-300"
                                            placeholder="作業書データ"
                                        />
                                    </div>
                                    <div className="h-6 w-px bg-gray-300 mx-1"></div>
                                    <button 
                                        onClick={saveData}
                                        disabled={steps.length === 0}
                                        className={`flex items-center gap-1 px-3 py-2 rounded shadow-sm disabled:opacity-50 text-sm whitespace-nowrap transition-colors ${
                                            hasUnsavedChanges && steps.length > 0 
                                            ? "bg-indigo-50 text-indigo-700 border border-indigo-200 font-bold" 
                                            : "bg-white text-gray-700 hover:bg-gray-50"
                                        }`}
                                        title="編集データをPCに保存"
                                    >
                                        <Save className="w-4 h-4" /> 
                                        {hasUnsavedChanges && steps.length > 0 ? "保存*" : "保存"}
                                    </button>
                                    <button onClick={() => jsonInputRef.current?.click()} className="flex items-center gap-1 px-3 py-2 bg-white text-gray-700 rounded shadow-sm hover:bg-gray-50 text-sm whitespace-nowrap" title="編集データを読み込み">
                                        <Upload className="w-4 h-4" /> 読込
                                    </button>
                                    <input type="file" accept=".json" ref={jsonInputRef} className="hidden" onChange={loadData} />
                                </div>

                                <button 
                                    onClick={handlePrint}
                                    className="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors text-sm shadow-md whitespace-nowrap"
                                >
                                    <Printer className="w-4 h-4" />
                                    印刷 / PDF保存
                                </button>
                            </div>
                        </header>

                        {/* Main Content Area */}
                        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 print-block">
                            
                            {/* Left Column: Video Player & Controls (Sticky) */}
                            <div className="lg:col-span-1 print-hidden">
                                <div className="bg-white rounded-xl shadow-sm p-4 sticky top-6">
                                    <h2 className="font-semibold mb-4 flex items-center gap-2">
                                        <FileVideo className="w-5 h-5 text-indigo-500" />
                                        ソース動画
                                    </h2>
                                    
                                    {!videoSrc ? (
                                        <div 
                                            onClick={() => fileInputRef.current?.click()}
                                            className="border-2 border-dashed border-gray-300 rounded-lg h-64 flex flex-col items-center justify-center cursor-pointer hover:bg-gray-50 transition-colors"
                                        >
                                            <FileVideo className="w-12 h-12 text-gray-300 mb-2" />
                                            <p className="text-gray-500 font-medium">動画ファイルを選択</p>
                                            <p className="text-xs text-gray-400 mt-1">クリックしてアップロード</p>
                                        </div>
                                    ) : (
                                        <div className="space-y-4">
                                            <div className="relative rounded-lg overflow-hidden bg-black aspect-video group">
                                                <video 
                                                    ref={videoRef}
                                                    src={videoSrc}
                                                    controls
                                                    className="w-full h-full object-contain"
                                                    crossOrigin="anonymous"
                                                />
                                            </div>
                                            
                                            <div className="flex gap-2">
                                                <button 
                                                    onClick={captureFrame}
                                                    className="flex-1 flex items-center justify-center gap-2 bg-indigo-600 text-white py-3 rounded-lg hover:bg-indigo-700 transition-colors font-medium shadow-md active:transform active:scale-95"
                                                >
                                                    <Camera className="w-5 h-5" />
                                                    今の画面をキャプチャ
                                                </button>
                                                <button 
                                                    onClick={() => setVideoSrc(null)}
                                                    className="px-3 py-3 bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200"
                                                    title="動画を変更"
                                                >
                                                    <Trash2 className="w-5 h-5" />
                                                </button>
                                            </div>
                                            <p className="text-xs text-gray-500 text-center">
                                                動画を再生・一時停止し、「キャプチャ」ボタンで作業に追加します
                                            </p>
                                        </div>
                                    )}
                                    <input 
                                        type="file" 
                                        accept="video/*" 
                                        ref={fileInputRef}
                                        className="hidden" 
                                        onChange={handleFileUpload}
                                    />
                                    
                                    <canvas ref={canvasRef} className="hidden" />
                                </div>
                            </div>

                            {/* Right Column: Step List */}
                            <div className="lg:col-span-2">
                                <div className="bg-white rounded-xl shadow-sm p-6 min-h-[600px] main-content">
                                    <div className="flex justify-between items-center mb-6 border-b pb-2 print-hidden">
                                        <h2 className="font-semibold flex items-center gap-2 text-lg">
                                            <FileText className="w-5 h-5 text-indigo-500" />
                                            作成された作業項目 ({steps.length})
                                        </h2>
                                        {steps.length === 0 && (
                                            <span className="text-sm text-gray-400">まだ作業項目がありません</span>
                                        )}
                                    </div>

                                    {steps.length === 0 ? (
                                        <div className="flex flex-col items-center justify-center h-96 text-gray-400 print-hidden">
                                            <Camera className="w-16 h-16 mb-4 text-gray-200" />
                                            <p className="text-lg font-bold text-gray-800">使い方</p>
                                            <div className="text-sm mt-4 space-y-2 text-left bg-gray-50 p-6 rounded-lg max-w-md">
                                                <p>1. 左側の<b>「動画ファイルを選択」</b>から動画を読み込みます。</p>
                                                <p>2. 動画を再生し、切り出したいシーンで<b>「キャプチャ」</b>ボタンを押します。</p>
                                                <p>3. 画像がここに追加されます。横のテキストボックスに説明を入力します。</p>
                                                <p>4. 右上の<b>「データ保存」</b>で作業を一時保存できます。</p>
                                                <p>5. 完成したら<b>「印刷 / PDF保存」</b>で書き出します。</p>
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="space-y-8 print:space-y-0">
                                            {steps.map((step, index) => {
                                                const isColLayout = step.layout === 'col';
                                                
                                                return (
                                                <div 
                                                    key={step.id} 
                                                    className={`group relative flex gap-6 p-4 rounded-xl border border-gray-100 hover:border-indigo-100 hover:bg-indigo-50/30 transition-all step-item ${
                                                        isColLayout 
                                                            ? 'flex-col step-col' // 縦並び
                                                            : 'flex-col md:flex-row step-row' // 横並び
                                                    }`}
                                                >
                                                    
                                                    {/* Image Area */}
                                                    <div 
                                                        className={`flex-shrink-0 step-image-container relative cursor-move ${
                                                            isColLayout ? 'w-full' : ''
                                                        }`}
                                                        style={!isColLayout ? { width: `${(steps[index].splitRatio || 0.5) * 100}%` } : {}}
                                                        onMouseDown={(e) => handleImageMouseDown(index, e)}
                                                    >
                                                        {/* aspect-videoで固定比率 */}
                                                        <div 
                                                            className={`relative w-full overflow-hidden border border-gray-200 shadow-sm aspect-video bg-gray-100 flex items-center justify-center`}
                                                            onClick={(e) => {
                                                                if (annotationTool && (e.target === e.currentTarget || e.target.tagName === 'svg' || e.target.tagName === 'IMG')) {
                                                                    const containerRef = { current: e.currentTarget };
                                                                    addAnnotation(index, annotationTool, e.clientX, e.clientY, containerRef);
                                                                }
                                                            }}
                                                            style={{ cursor: annotationTool ? 'crosshair' : 'default' }}
                                                        >
                                                            <img 
                                                                src={step.image} 
                                                                alt={`Step ${index + 1}`} 
                                                                className="w-full h-full object-contain transition-transform duration-75 ease-out select-none pointer-events-none" 
                                                                style={{ 
                                                                    transform: `translate(${step.x || 0}px, ${step.y || 0}px) scale(${step.scale || 1})` 
                                                                }}
                                                                draggable="false"
                                                            />
                                                            
                                                            {/* 注釈オーバーレイ (SVG) */}
                                                            <svg 
                                                                className="absolute inset-0 w-full h-full pointer-events-none z-20"
                                                                style={{ pointerEvents: annotationTool ? 'auto' : 'none' }}
                                                                viewBox="0 0 100 100"
                                                                preserveAspectRatio="xMidYMid meet"
                                                            >
                                                                {(step.annotations || []).map((annotation) => {
                                                                    const x = annotation.x;
                                                                    const y = annotation.y;
                                                                    const isHovered = hoveredAnnotation && 
                                                                        hoveredAnnotation.stepIndex === index && 
                                                                        hoveredAnnotation.annotationId === annotation.id;
                                                                    const arrowLength = annotation.type === 'arrow' ? (annotation.length || 16) : 0;
                                                                    const arrowRotation = annotation.type === 'arrow' ? (annotation.rotation || 0) : 0;
                                                                    
                                                                    return (
                                                                        <g 
                                                                            key={annotation.id}
                                                                            transform={`translate(${x}, ${y}) scale(${annotation.size || 1.0})`}
                                                                            className="pointer-events-auto"
                                                                            onMouseEnter={() => {
                                                                                if (!annotationTool) {
                                                                                    // 別の図形にホバーしたときは、前の図形のホバー状態を解除して新しい状態を設定
                                                                                    setHoveredAnnotation({ stepIndex: index, annotationId: annotation.id });
                                                                                }
                                                                            }}
                                                                            onMouseLeave={() => {
                                                                                // ボタンに移動する際はホバー状態を維持するため、少し遅延させる
                                                                                setTimeout(() => {
                                                                                    setHoveredAnnotation(prev => {
                                                                                        // 別の図形にホバーしている場合は解除しない
                                                                                        if (prev && prev.stepIndex === index && prev.annotationId === annotation.id) {
                                                                                            return null;
                                                                                        }
                                                                                        return prev;
                                                                                    });
                                                                                }, 150);
                                                                            }}
                                                                        >
                                                                            {/* 広いホバー領域（透明） */}
                                                                            <circle 
                                                                                cx="0" 
                                                                                cy="0" 
                                                                                r="15" 
                                                                                fill="transparent" 
                                                                                className="cursor-move"
                                                                                onMouseDown={(e) => {
                                                                                    if (!annotationTool) {
                                                                                        handleAnnotationMouseDown(index, annotation.id, e);
                                                                                    }
                                                                                    e.stopPropagation();
                                                                                }}
                                                                                onMouseEnter={() => {
                                                                                    if (!annotationTool) {
                                                                                        setHoveredAnnotation({ stepIndex: index, annotationId: annotation.id });
                                                                                    }
                                                                                }}
                                                                                style={{ cursor: annotationTool ? 'crosshair' : 'move' }}
                                                                            />
                                                                            
                                                                            {annotation.type === 'arrow' && (
                                                                                <g transform={`rotate(${arrowRotation})`}>
                                                                                    <line 
                                                                                        x1={-arrowLength / 2} 
                                                                                        y1="0" 
                                                                                        x2={arrowLength / 2 - 2} 
                                                                                        y2="0" 
                                                                                        stroke="#dc2626" 
                                                                                        strokeWidth="1.5" 
                                                                                        strokeLinecap="round"
                                                                                        className="pointer-events-none"
                                                                                    />
                                                                                    <polygon 
                                                                                        points={`${arrowLength / 2},0 ${arrowLength / 2 - 4},-3 ${arrowLength / 2 - 4},3`}
                                                                                        fill="#dc2626" 
                                                                                        stroke="#dc2626" 
                                                                                        strokeWidth="1.2"
                                                                                        className="pointer-events-none"
                                                                                    />
                                                                                </g>
                                                                            )}
                                                                            {annotation.type === 'circle' && (
                                                                                <circle 
                                                                                    cx="0" 
                                                                                    cy="0" 
                                                                                    r="5" 
                                                                                    fill="none" 
                                                                                    stroke="#dc2626" 
                                                                                    strokeWidth="1.5"
                                                                                    className="pointer-events-none"
                                                                                />
                                                                            )}
                                                                            {/* 削除ボタンとサイズ変更ボタン - ホバー時のみ表示 */}
                                                                            {!annotationTool && isHovered && (
                                                                                <>
                                                                                    {/* 削除ボタン - 矢印の場合は左上、円形の場合は右上 */}
                                                                                    <g 
                                                                                        className="cursor-pointer hover:opacity-80 print-hidden"
                                                                                        onClick={(e) => {
                                                                                            e.stopPropagation();
                                                                                            deleteAnnotation(index, annotation.id);
                                                                                        }}
                                                                                        onMouseEnter={() => {
                                                                                            setHoveredAnnotation({ stepIndex: index, annotationId: annotation.id });
                                                                                        }}
                                                                                        transform={annotation.type === 'arrow' ? "translate(-7, -7)" : "translate(7, -7)"}
                                                                                    >
                                                                                        <circle cx="0" cy="0" r="2" fill="#dc2626" />
                                                                                        <line x1="-1" y1="0" x2="1" y2="0" stroke="white" strokeWidth="0.5" />
                                                                                    </g>
                                                                                    {/* サイズ変更ボタン */}
                                                                                    <g 
                                                                                        className="cursor-pointer hover:opacity-80 print-hidden"
                                                                                        onClick={(e) => {
                                                                                            e.stopPropagation();
                                                                                            resizeAnnotation(index, annotation.id, 0.2);
                                                                                        }}
                                                                                        onMouseEnter={() => {
                                                                                            setHoveredAnnotation({ stepIndex: index, annotationId: annotation.id });
                                                                                        }}
                                                                                        transform="translate(7, 7)"
                                                                                        title="拡大"
                                                                                    >
                                                                                        <circle cx="0" cy="0" r="2" fill="#3b82f6" />
                                                                                        <line x1="0" y1="-0.8" x2="0" y2="0.8" stroke="white" strokeWidth="0.4" />
                                                                                        <line x1="-0.8" y1="0" x2="0.8" y2="0" stroke="white" strokeWidth="0.4" />
                                                                                    </g>
                                                                                    <g 
                                                                                        className="cursor-pointer hover:opacity-80 print-hidden"
                                                                                        onClick={(e) => {
                                                                                            e.stopPropagation();
                                                                                            resizeAnnotation(index, annotation.id, -0.2);
                                                                                        }}
                                                                                        onMouseEnter={() => {
                                                                                            setHoveredAnnotation({ stepIndex: index, annotationId: annotation.id });
                                                                                        }}
                                                                                        transform="translate(-7, 7)"
                                                                                        title="縮小"
                                                                                    >
                                                                                        <circle cx="0" cy="0" r="2" fill="#3b82f6" />
                                                                                        <line x1="-0.8" y1="0" x2="0.8" y2="0" stroke="white" strokeWidth="0.4" />
                                                                                    </g>
                                                                                    {/* 矢印専用: 回転ボタン */}
                                                                                    {annotation.type === 'arrow' && (
                                                                                        <>
                                                                                            <g 
                                                                                                className="cursor-pointer hover:opacity-80 print-hidden"
                                                                                                onClick={(e) => {
                                                                                                    e.stopPropagation();
                                                                                                    rotateAnnotation(index, annotation.id, 15);
                                                                                                }}
                                                                                                onMouseEnter={() => {
                                                                                                    setHoveredAnnotation({ stepIndex: index, annotationId: annotation.id });
                                                                                                }}
                                                                                                transform="translate(0, -7)"
                                                                                                title="時計回りに回転"
                                                                                            >
                                                                                                <circle cx="0" cy="0" r="2" fill="#10b981" />
                                                                                                <path d="M 0 -1 L 0.5 0.5 M 0 -1 L -0.5 0.5" stroke="white" strokeWidth="0.4" fill="none" strokeLinecap="round" />
                                                                                            </g>
                                                                                            <g 
                                                                                                className="cursor-pointer hover:opacity-80 print-hidden"
                                                                                                onClick={(e) => {
                                                                                                    e.stopPropagation();
                                                                                                    rotateAnnotation(index, annotation.id, -15);
                                                                                                }}
                                                                                                onMouseEnter={() => {
                                                                                                    setHoveredAnnotation({ stepIndex: index, annotationId: annotation.id });
                                                                                                }}
                                                                                                transform="translate(7, -7)"
                                                                                                title="反時計回りに回転"
                                                                                            >
                                                                                                <circle cx="0" cy="0" r="2" fill="#10b981" />
                                                                                                <path d="M 0 -1 L -0.5 0.5 M 0 -1 L 0.5 0.5" stroke="white" strokeWidth="0.4" fill="none" strokeLinecap="round" />
                                                                                            </g>
                                                                                            {/* 矢印の長さ変更ボタン */}
                                                                                            <g 
                                                                                                className="cursor-pointer hover:opacity-80 print-hidden"
                                                                                                onClick={(e) => {
                                                                                                    e.stopPropagation();
                                                                                                    changeArrowLength(index, annotation.id, 2);
                                                                                                }}
                                                                                                onMouseEnter={() => {
                                                                                                    setHoveredAnnotation({ stepIndex: index, annotationId: annotation.id });
                                                                                                }}
                                                                                                transform="translate(-7, 7)"
                                                                                                title="長さを伸ばす"
                                                                                            >
                                                                                                <circle cx="0" cy="0" r="2" fill="#f59e0b" />
                                                                                                <line x1="-0.8" y1="0" x2="0.8" y2="0" stroke="white" strokeWidth="0.4" />
                                                                                                <line x1="0" y1="-0.5" x2="0" y2="0.5" stroke="white" strokeWidth="0.4" />
                                                                                            </g>
                                                                                            <g 
                                                                                                className="cursor-pointer hover:opacity-80 print-hidden"
                                                                                                onClick={(e) => {
                                                                                                    e.stopPropagation();
                                                                                                    changeArrowLength(index, annotation.id, -2);
                                                                                                }}
                                                                                                onMouseEnter={() => {
                                                                                                    setHoveredAnnotation({ stepIndex: index, annotationId: annotation.id });
                                                                                                }}
                                                                                                transform="translate(0, 7)"
                                                                                                title="長さを縮める"
                                                                                            >
                                                                                                <circle cx="0" cy="0" r="2" fill="#f59e0b" />
                                                                                                <line x1="-0.8" y1="0" x2="0.8" y2="0" stroke="white" strokeWidth="0.4" />
                                                                                            </g>
                                                                                        </>
                                                                                    )}
                                                                                </>
                                                                            )}
                                                                        </g>
                                                                    );
                                                                })}
                                                                {/* 矢印のマーカー定義 */}
                                                                <defs>
                                                                    <marker 
                                                                        id="arrowhead-red" 
                                                                        markerWidth="1" 
                                                                        markerHeight="1" 
                                                                        refX="0.9" 
                                                                        refY="0.3" 
                                                                        orient="auto"
                                                                        markerUnits="strokeWidth"
                                                                    >
                                                                        <polygon points="0 0, 1 0.3, 0 0.6" fill="#dc2626" />
                                                                    </marker>
                                                                </defs>
                                                            </svg>
                                                            
                                                            <div className="absolute top-2 left-2 bg-black/70 text-white text-xs px-2 py-1 rounded-md font-mono z-10 pointer-events-none">
                                                                Step {index + 1}
                                                            </div>
                                                        </div>
                                                        
                                                        {/* Controls - 画像の下に配置 */}
                                                        <div 
                                                            className="flex flex-wrap items-center justify-center gap-2 mt-2 print-hidden"
                                                            onMouseDown={(e) => e.stopPropagation()} 
                                                        >
                                                            {/* 注釈ツール */}
                                                            <div className="flex gap-2 bg-white rounded-lg p-1 shadow-sm border border-gray-200">
                                                                <button 
                                                                    onClick={() => setAnnotationTool(annotationTool === 'arrow' ? null : 'arrow')}
                                                                    className={`p-2 rounded transition-colors ${
                                                                        annotationTool === 'arrow' 
                                                                            ? 'bg-red-500 text-white' 
                                                                            : 'text-gray-700 hover:bg-red-50 hover:text-red-600'
                                                                    }`}
                                                                    title="矢印を追加"
                                                                >
                                                                    <ArrowRight className="w-5 h-5" />
                                                                </button>
                                                                <button 
                                                                    onClick={() => setAnnotationTool(annotationTool === 'circle' ? null : 'circle')}
                                                                    className={`p-2 rounded transition-colors ${
                                                                        annotationTool === 'circle' 
                                                                            ? 'bg-red-500 text-white' 
                                                                            : 'text-gray-700 hover:bg-red-50 hover:text-red-600'
                                                                    }`}
                                                                    title="円形を追加"
                                                                >
                                                                    <Circle className="w-5 h-5" />
                                                                </button>
                                                            </div>
                                                            
                                                            {/* 画像操作ツール */}
                                                            <div className="flex gap-2 bg-white rounded-lg p-1 shadow-sm border border-gray-200">
                                                                <button 
                                                                    onClick={() => resetImage(index)}
                                                                    className="bg-white text-gray-700 hover:text-red-500 hover:bg-red-50 shadow-sm p-2 rounded transition-colors"
                                                                    title="位置と拡大をリセット"
                                                                >
                                                                    <RefreshCcw className="w-5 h-5" />
                                                                </button>
                                                                <button 
                                                                    onClick={() => zoomImage(index, -0.1)}
                                                                    className="bg-white text-gray-700 hover:text-indigo-600 hover:bg-indigo-50 shadow-sm p-2 rounded transition-colors"
                                                                    title="縮小"
                                                                >
                                                                    <ZoomOut className="w-5 h-5" />
                                                                </button>
                                                                <button 
                                                                    onClick={() => zoomImage(index, 0.1)}
                                                                    className="bg-white text-gray-700 hover:text-indigo-600 hover:bg-indigo-50 shadow-sm p-2 rounded transition-colors"
                                                                    title="拡大"
                                                                >
                                                                    <ZoomIn className="w-5 h-5" />
                                                                </button>
                                                                <button 
                                                                    onClick={() => rotateImage(index)}
                                                                    className="bg-white text-gray-700 hover:text-indigo-600 hover:bg-indigo-50 shadow-sm p-2 rounded transition-colors"
                                                                    title="画像を90度回転"
                                                                >
                                                                    <RotateCw className="w-5 h-5" />
                                                                </button>
                                                            </div>
                                                        </div>
                                                    </div>

                                                    {/* Split Bar (横並びの時のみ表示) */}
                                                    {!isColLayout && (
                                                        <div 
                                                            className="w-1 bg-indigo-300 hover:bg-indigo-500 cursor-col-resize transition-colors flex-shrink-0 relative group print-hidden"
                                                            onMouseDown={(e) => {
                                                                const container = e.currentTarget.closest('.step-item');
                                                                if (container) {
                                                                    const containerRef = { current: container };
                                                                    handleSplitMouseDown(index, e, containerRef);
                                                                }
                                                            }}
                                                            style={{ 
                                                                cursor: splitDragState.isDragging ? 'col-resize' : 'col-resize',
                                                                backgroundColor: splitDragState.stepIndex === index && splitDragState.isDragging ? '#6366f1' : '#a5b4fc'
                                                            }}
                                                        >
                                                            <div className="absolute inset-y-0 left-1/2 transform -translate-x-1/2 w-3 group-hover:bg-indigo-400/50"></div>
                                                        </div>
                                                    )}

                                                    {/* Text Area */}
                                                    <div 
                                                        className={`flex flex-col gap-2 step-text-container ${
                                                            isColLayout ? 'w-full' : ''
                                                        }`}
                                                        style={!isColLayout ? { width: `${(1 - (steps[index].splitRatio || 0.5)) * 100}%` } : {}}
                                                    >
                                                        <textarea
                                                            value={step.text}
                                                            onChange={(e) => handleTextChange(index, e.target.value)}
                                                            className="w-full h-full min-h-[120px] p-3 rounded-lg border border-gray-200 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 outline-none resize-none text-gray-700 leading-relaxed"
                                                            placeholder="作業の説明を入力してください..."
                                                        />
                                                    </div>

                                                    {/* Controls (Move, Layout, Delete) */}
                                                    <div className="absolute -top-3 -right-3 flex gap-1 print-hidden">
                                                        {/* レイアウト切り替えボタン */}
                                                        <button
                                                            onClick={() => toggleLayout(index)}
                                                            className={`bg-white border shadow-sm p-1.5 rounded-md transition-colors mr-2 ${
                                                                isColLayout 
                                                                ? "text-indigo-600 border-indigo-200 bg-indigo-50" 
                                                                : "text-gray-500 hover:text-indigo-600"
                                                            }`}
                                                            title={isColLayout ? "横並びに戻す" : "画像を大きく表示（縦並び）"}
                                                        >
                                                            {isColLayout ? <LayoutRow className="w-4 h-4" /> : <LayoutCol className="w-4 h-4" />}
                                                        </button>

                                                        <button 
                                                            onClick={() => moveStep(index, -1)}
                                                            disabled={index === 0}
                                                            className="bg-white text-gray-500 hover:text-indigo-600 border shadow-sm p-1.5 rounded-md disabled:opacity-30 disabled:cursor-not-allowed transition-colors"
                                                            title="上へ移動"
                                                        >
                                                            <ArrowUp className="w-4 h-4" />
                                                        </button>
                                                        <button 
                                                            onClick={() => moveStep(index, 1)}
                                                            disabled={index === steps.length - 1}
                                                            className="bg-white text-gray-500 hover:text-indigo-600 border shadow-sm p-1.5 rounded-md disabled:opacity-30 disabled:cursor-not-allowed transition-colors"
                                                            title="下へ移動"
                                                        >
                                                            <ArrowDown className="w-4 h-4" />
                                                        </button>
                                                        <button 
                                                            onClick={() => deleteStep(index)}
                                                            className="bg-white text-gray-400 hover:text-red-500 border shadow-sm p-1.5 rounded-md transition-colors"
                                                            title="この作業を削除"
                                                        >
                                                            <Trash2 className="w-4 h-4" />
                                                        </button>
                                                    </div>
                                                </div>
                                            );
                                            })}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
