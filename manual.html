<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作業書作成支援ツール</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect x='8' y='8' width='48' height='48' rx='8' fill='%234f46e5'/%3E%3Cpath d='M26 22 L26 42 L44 32 Z' fill='%23ffffff'/%3E%3C/svg%3E">

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* 画面全体のレイアウト */
        body, html {
            height: 100%;
            overflow: hidden; /* 全体スクロールを禁止 */
        }

        /* --- 印刷用スタイル --- */
        @media print {
            /* ページ設定: A4サイズ、余白なし（ブラウザの「なし」「最小」に最適化） */
            @page {
                size: A4 portrait;
                margin: 0;
            }

            body, html {
                height: auto;
                overflow: visible;
                background: white;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            .print-hidden { display: none !important; }
            .print-block { display: block !important; }

            .scroll-area {
                height: auto !important;
                overflow: visible !important;
                background: white !important;
                padding: 0 !important;
                margin: 0 !important;
            }

            /* メインフレックスコンテナを印刷用にリセット */
            .flex-1.flex.overflow-hidden {
                display: block !important;
                overflow: visible !important;
            }

            .a4-preview,
            .right-content {
                width: 100% !important;
                max-width: none !important;
                box-shadow: none !important;
                margin: 0 !important;
                padding: 0 !important;
                background: white !important;
                min-height: 0 !important;
                background-image: none !important;
            }
            
            /* ステップ間隔の統一 */
            .space-y-6 {
                margin: 0 !important;
                padding: 0 !important;
            }
            .space-y-6 > * + * {
                margin-top: 8px !important;
            }

            .step-item {
                break-inside: avoid;
                page-break-inside: avoid;
                border: 1px solid #ddd !important;
                margin: 0 0 1mm 0 !important;
                padding: 2mm !important;
                height: 73mm !important;
                max-height: 73mm !important;
                overflow: hidden !important;
                display: flex !important;
                flex-direction: row !important;
                gap: 2mm !important;
                page-break-after: auto;
                border-radius: 0 !important;
                box-shadow: none !important;
                box-sizing: border-box !important;
            }

            /* 印刷時の画像コンテナ: 55% */
            .step-item > div:first-child {
                width: 55% !important;
                height: 100% !important;
                flex-shrink: 0 !important;
            }

            /* 印刷時のテキストコンテナ: 43% */
            .step-text-container {
                width: 43% !important;
                height: 100% !important;
                flex-shrink: 0 !important;
                padding: 1.5mm !important;
                box-sizing: border-box !important;
            }

            .step-image-mask {
                overflow: hidden !important;
                width: 100% !important;
                height: 100% !important;
                max-height: none !important;
            }

            .step-image-mask > div {
                height: 100% !important;
            }

            /* リッチテキストエディタの印刷時スタイル */
            .rich-text-editor {
                height: 100% !important;
                overflow: auto !important;
                border: 1px solid #e5e7eb !important;
                padding: 2mm !important;
                padding-right: 3mm !important;
                box-shadow: none !important;
                box-sizing: border-box !important;
                word-wrap: break-word !important;
                word-break: break-word !important;
                line-height: 1.4 !important;
            }
            
            .lg\:col-span-8 {
                width: 100% !important;
                grid-column: span 12 / span 12 !important;
            }

            /* h-full等のフルハイト指定を解除 */
            .h-full {
                height: auto !important;
            }
        }

        /* カスタムスクロールバー */
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        textarea.resize-vertical {
            resize: vertical !important;
            min-height: 100px;
        }

        /* contentEditableプレースホルダー */
        .rich-text-editor:empty:before {
            content: attr(data-placeholder);
            color: #9ca3af;
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 font-sans">
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // --- Icons ---
        const IconBase = ({ children, size = 18, className = "", ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>
                {children}
            </svg>
        );

        const Camera = (props) => (<IconBase {...props}><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path><circle cx="12" cy="13" r="3"></circle></IconBase>);
        const FileVideo = (props) => (<IconBase {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="m10 11 5 3-5 3v-6z"></path></IconBase>);
        const FileImage = (props) => (<IconBase {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></IconBase>);
        const Trash2 = (props) => (<IconBase {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></IconBase>);
        const Printer = (props) => (<IconBase {...props}><polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect></IconBase>);
        const FileText = (props) => (<IconBase {...props}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></IconBase>);
        const Save = (props) => (<IconBase {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></IconBase>);
        const Upload = (props) => (<IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></IconBase>);
        const ArrowUp = (props) => (<IconBase {...props}><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></IconBase>);
        const ArrowDown = (props) => (<IconBase {...props}><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></IconBase>);
        const RotateCw = (props) => (<IconBase {...props}><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></IconBase>);
        const ZoomIn = (props) => (<IconBase {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></IconBase>);
        const ZoomOut = (props) => (<IconBase {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></IconBase>);
        const RefreshCcw = (props) => (<IconBase {...props}><polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></IconBase>);
        const ArrowRight = (props) => (<IconBase {...props}><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></IconBase>);
        const Circle = (props) => (<IconBase {...props}><circle cx="12" cy="12" r="10"></circle></IconBase>);
        const PlusCircle = (props) => (<IconBase {...props}><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></IconBase>);
        const Type = (props) => (<IconBase {...props}><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></IconBase>);
        const Hash = (props) => (<IconBase {...props}><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></IconBase>);

        // --- Rich Text Editor Component ---
        function RichTextEditor({ value, onChange, placeholder, style, className }) {
            const editorRef = useRef(null);
            const lastHtml = useRef('');

            useEffect(() => {
                if (editorRef.current && value !== lastHtml.current) {
                    editorRef.current.innerHTML = value || '';
                    lastHtml.current = value || '';
                }
            }, [value]);

            const handleInput = () => {
                const html = editorRef.current.innerHTML;
                lastHtml.current = html;
                if (onChange) onChange(html);
            };

            const execCmd = (e, cmd, val) => {
                e.preventDefault();
                e.stopPropagation();
                editorRef.current.focus();
                document.execCommand(cmd, false, val);
                handleInput();
            };

            return (
                <div style={style} className={className + ' flex flex-col'}>
                    <div
                        ref={editorRef}
                        contentEditable
                        suppressContentEditableWarning
                        onInput={handleInput}
                        data-placeholder={placeholder}
                        className="rich-text-editor w-full p-3 rounded-lg border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-100 outline-none text-gray-700 leading-relaxed shadow-inner overflow-auto"
                        style={{ flex: 1, fontSize: '16px', minHeight: 0 }}
                    />
                    <div className="flex gap-1 mt-1 print-hidden flex-wrap" style={{ fontSize: '11px' }}>
                        <button onMouseDown={(e) => execCmd(e, 'bold')} className="px-2 py-0.5 bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 font-bold" title="太字">B</button>
                        <button onMouseDown={(e) => execCmd(e, 'foreColor', '#dc2626')} className="px-2 py-0.5 bg-gray-100 hover:bg-red-100 rounded border border-gray-300 text-red-600" title="赤文字">赤</button>
                        <button onMouseDown={(e) => execCmd(e, 'foreColor', '#1d4ed8')} className="px-2 py-0.5 bg-gray-100 hover:bg-blue-100 rounded border border-gray-300 text-blue-700" title="青文字">青</button>
                        <button onMouseDown={(e) => execCmd(e, 'foreColor', '#000000')} className="px-2 py-0.5 bg-gray-100 hover:bg-gray-200 rounded border border-gray-300" title="黒文字">黒</button>
                        <span className="w-px bg-gray-300 mx-0.5"></span>
                        <button onMouseDown={(e) => execCmd(e, 'fontSize', '2')} className="px-2 py-0.5 bg-gray-100 hover:bg-gray-200 rounded border border-gray-300" title="小">小</button>
                        <button onMouseDown={(e) => execCmd(e, 'fontSize', '4')} className="px-2 py-0.5 bg-gray-100 hover:bg-gray-200 rounded border border-gray-300" title="中">中</button>
                        <button onMouseDown={(e) => execCmd(e, 'fontSize', '6')} className="px-2 py-0.5 bg-gray-100 hover:bg-gray-200 rounded border border-gray-300" title="大">大</button>
                    </div>
                </div>
            );
        }

        // --- Main Component ---
        function App() {
            const [videoSrc, setVideoSrc] = useState(null);
            const [steps, setSteps] = useState([]);
            const [fileName, setFileName] = useState("");
            const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

            const [dragState, setDragState] = useState({ isDragging: false, stepIndex: null, startX: 0, startY: 0, initialImgX: 0, initialImgY: 0 });
            const [splitDragState, setSplitDragState] = useState({ isDragging: false, stepIndex: null, startX: 0, startY: 0, containerWidth: 0, initialRatio: 0.5 });

            const [annotationTool, setAnnotationTool] = useState(null);
            const [selectedAnnotation, setSelectedAnnotation] = useState(null);
            const [handleDragState, setHandleDragState] = useState(null);
            const [activeStepIndex, setActiveStepIndex] = useState(null);
            const [selectedSteps, setSelectedSteps] = useState(new Set());
            const [selectionMode, setSelectionMode] = useState(false);
            const [deleteConfirm, setDeleteConfirm] = useState({ show: false, index: null });

            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const fileInputRef = useRef(null);
            const imageInputRef = useRef(null); // 画像用
            const jsonInputRef = useRef(null);
            const stepsEndRef = useRef(null);
            const scrollAreaRef = useRef(null);

            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    if (hasUnsavedChanges && steps.length > 0) {
                        e.preventDefault(); e.returnValue = ''; 
                    }
                };
                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [hasUnsavedChanges, steps]);

            // --- 画像ドラッグ ---
            const handleImageMouseDown = (index, e) => {
                if (annotationTool || selectedAnnotation) {
                    if (selectedAnnotation) setSelectedAnnotation(null);
                    return; 
                }
                e.preventDefault(); 
                setDragState({ isDragging: true, stepIndex: index, startX: e.clientX, startY: e.clientY, initialImgX: steps[index].x || 0, initialImgY: steps[index].y || 0 });
            };

            const handleImageMouseMove = (e) => {
                if (!dragState.isDragging || dragState.stepIndex === null) return;
                e.preventDefault();
                const deltaX = e.clientX - dragState.startX;
                const deltaY = e.clientY - dragState.startY;
                setSteps(prev => {
                    const next = [...prev];
                    next[dragState.stepIndex].x = dragState.initialImgX + deltaX;
                    next[dragState.stepIndex].y = dragState.initialImgY + deltaY;
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const handleImageMouseUp = () => {
                if (dragState.isDragging) setDragState({ isDragging: false, stepIndex: null, startX: 0, startY: 0, initialImgX: 0, initialImgY: 0 });
            };

            // --- 分割バードラッグ ---
            const handleSplitMouseDown = (index, e, containerRef) => {
                e.preventDefault(); e.stopPropagation();
                const container = containerRef.current;
                if (container) {
                    setSplitDragState({ isDragging: true, stepIndex: index, startX: e.clientX, startY: e.clientY, containerWidth: container.offsetWidth, initialRatio: steps[index].splitRatio || 0.5 });
                }
            };
            const handleSplitMouseMove = (e) => {
                if (!splitDragState.isDragging || splitDragState.stepIndex === null) return;
                e.preventDefault();
                setSteps(prev => {
                    const next = [...prev];
                    const deltaX = e.clientX - splitDragState.startX;
                    const newRatio = Math.max(0.2, Math.min(0.8, splitDragState.initialRatio + (deltaX / splitDragState.containerWidth)));
                    next[splitDragState.stepIndex].splitRatio = newRatio;
                    return next;
                });
                setHasUnsavedChanges(true);
            };
            const handleSplitMouseUp = () => {
                if (splitDragState.isDragging) setSplitDragState(prev => ({ ...prev, isDragging: false, stepIndex: null }));
            };

            // --- 注釈ハンドル操作 ---
            const handleHandleMouseDown = (e, type, stepIndex, annId) => {
                e.preventDefault(); e.stopPropagation();
                const container = e.target.closest('.step-image-mask');
                if (!container) return;
                const rect = container.getBoundingClientRect();
                const ann = steps[stepIndex].annotations.find(a => a.id === annId);
                if(!ann) return;

                setHandleDragState({
                    isDragging: true,
                    type: type, 
                    stepIndex,
                    annotationId: annId,
                    startX: e.clientX,
                    startY: e.clientY,
                    rect: rect,
                    initialAnn: JSON.parse(JSON.stringify(ann))
                });
            };

            const handleHandleMouseMove = (e) => {
                if (!handleDragState || !handleDragState.isDragging) return;
                e.preventDefault();
                const { type, stepIndex, annotationId, startX, startY, rect, initialAnn } = handleDragState;

                const deltaXPx = e.clientX - startX;
                const deltaYPx = e.clientY - startY;
                const deltaX = (deltaXPx / rect.width) * 100;
                const deltaY = (deltaYPx / rect.height) * 100;

                setSteps(prev => {
                    const next = [...prev];
                    const ann = next[stepIndex].annotations.find(a => a.id === annotationId);
                    if (!ann) return next;

                    if (type === 'move') {
                         ann.x = initialAnn.x + deltaX;
                         ann.y = initialAnn.y + deltaY;
                    } else if (type === 'resize-circle-w') {
                        // 横幅変更 (rx)
                        ann.rx = Math.max(1, initialAnn.rx + (deltaX / 2));
                    } else if (type === 'resize-circle-h') {
                        // 縦幅変更 (ry)
                        ann.ry = Math.max(1, initialAnn.ry + (deltaY / 2));
                    } else if (type === 'resize-text-label') {
                        // テキストラベルのフォントサイズ変更
                        ann.fontSize = Math.max(1, Math.min(30, initialAnn.fontSize + (deltaY / 10)));
                    } else if (type === 'resize-number-stamp') {
                        // 番号スタンプのサイズ変更
                        const avgDelta = (deltaX + deltaY) / 2;
                        ann.stampSize = Math.max(2, Math.min(15, initialAnn.stampSize + (avgDelta / 10)));
                    } else if (type === 'arrow-start' || type === 'arrow-end') {
                        const rad = initialAnn.rotation * Math.PI / 180;
                        const halfLen = initialAnn.length / 2;
                        let startX = initialAnn.x - halfLen * Math.cos(rad);
                        let startY = initialAnn.y - halfLen * Math.sin(rad);
                        let endX = initialAnn.x + halfLen * Math.cos(rad);
                        let endY = initialAnn.y + halfLen * Math.sin(rad);

                        if (type === 'arrow-start') {
                            startX += deltaX;
                            startY += deltaY;
                        } else {
                            endX += deltaX;
                            endY += deltaY;
                        }

                        const newCenterX = (startX + endX) / 2;
                        const newCenterY = (startY + endY) / 2;
                        const dx = endX - startX;
                        const dy = endY - startY;
                        const newLength = Math.sqrt(dx*dx + dy*dy);
                        const newRad = Math.atan2(dy, dx);

                        ann.x = newCenterX;
                        ann.y = newCenterY;
                        ann.length = newLength;
                        ann.rotation = newRad * 180 / Math.PI;
                    }

                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const handleHandleMouseUp = () => {
                if (handleDragState) setHandleDragState(null);
            };

            // Global Mouse Events
            useEffect(() => {
                const handleMove = (e) => {
                    handleImageMouseMove(e);
                    handleSplitMouseMove(e);
                    handleHandleMouseMove(e);
                };
                const handleUp = () => {
                    handleImageMouseUp();
                    handleSplitMouseUp();
                    handleHandleMouseUp();
                };
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
                return () => {
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                };
            }, [dragState, splitDragState, handleDragState]);

            // 注釈追加
            const addAnnotation = (stepIndex, type, x, y, containerRef) => {
                if (!annotationTool || !containerRef.current) return;
                const container = containerRef.current;
                const rect = container.getBoundingClientRect();
                const relativeX = ((x - rect.left) / rect.width) * 100;
                const relativeY = ((y - rect.top) / rect.height) * 100;

                // 円の初期サイズ計算 (見た目上の正円)
                const aspect = rect.width / rect.height;
                const initialRx = 5; // 横幅の5%
                const initialRy = 5 * aspect; // 縦幅の5% * アスペクト比

                // 番号スタンプの場合、既存の最大番号+1を自動設定
                let nextNumber = 1;
                if (type === 'number-stamp') {
                    const existingNumbers = (steps[stepIndex].annotations || [])
                        .filter(a => a.type === 'number-stamp')
                        .map(a => a.number || 1);
                    if (existingNumbers.length > 0) {
                        nextNumber = Math.max(...existingNumbers) + 1;
                    }
                }

                const newAnnotation = {
                    id: Date.now(),
                    type: type,
                    x: relativeX,
                    y: relativeY,
                    rx: initialRx, // 横半径
                    ry: initialRy, // 縦半径
                    size: 1.0, // 後方互換用(使わない)
                    rotation: 0,
                    length: 16,
                    strokeWidth: 2,
                    // テキストラベル用
                    text: type === 'text-label' ? 'テキスト' : undefined,
                    fontSize: type === 'text-label' ? 14 : undefined,
                    color: type === 'text-label' ? 'white' : undefined,
                    // 番号スタンプ用
                    number: type === 'number-stamp' ? nextNumber : undefined,
                    stampSize: type === 'number-stamp' ? 6 : undefined,
                };
                setSteps(prev => {
                    const newSteps = [...prev];
                    if (!newSteps[stepIndex].annotations) newSteps[stepIndex].annotations = [];
                    newSteps[stepIndex].annotations.push(newAnnotation);
                    return newSteps;
                });
                setHasUnsavedChanges(true);
                setAnnotationTool(null);
                setSelectedAnnotation({ stepIndex, annotationId: newAnnotation.id });
            };

            const deleteAnnotation = (stepIndex, annotationId) => {
                setSteps(prev => {
                    const newSteps = [...prev];
                    if (newSteps[stepIndex].annotations) {
                        newSteps[stepIndex].annotations = newSteps[stepIndex].annotations.filter(a => a.id !== annotationId);
                    }
                    return newSteps;
                });
                setSelectedAnnotation(null);
                setHasUnsavedChanges(true);
            };
            
            const changeStrokeWidth = (stepIndex, annotationId, delta) => {
                setSteps(prev => {
                    const next = [...prev];
                    const ann = next[stepIndex].annotations.find(a => a.id === annotationId);
                    if (ann) ann.strokeWidth = Math.max(0.5, Math.min(10, (ann.strokeWidth || 2) + delta));
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const editAnnotationText = (stepIndex, annotationId) => {
                const ann = steps[stepIndex].annotations.find(a => a.id === annotationId);
                if (!ann) return;

                if (ann.type === 'text-label') {
                    const newText = prompt('テキストを入力してください:', ann.text || '');
                    if (newText !== null) {
                        setSteps(prev => {
                            const next = [...prev];
                            const a = next[stepIndex].annotations.find(a => a.id === annotationId);
                            if (a) a.text = newText;
                            return next;
                        });
                        setHasUnsavedChanges(true);
                    }
                } else if (ann.type === 'number-stamp') {
                    const newNumber = prompt('番号を入力してください:', ann.number || 1);
                    if (newNumber !== null && !isNaN(newNumber)) {
                        setSteps(prev => {
                            const next = [...prev];
                            const a = next[stepIndex].annotations.find(a => a.id === annotationId);
                            if (a) a.number = parseInt(newNumber);
                            return next;
                        });
                        setHasUnsavedChanges(true);
                    }
                }
            };

            const changeTextLabelColor = (stepIndex, annotationId, color) => {
                setSteps(prev => {
                    const next = [...prev];
                    const ann = next[stepIndex].annotations.find(a => a.id === annotationId);
                    if (ann && ann.type === 'text-label') {
                        ann.color = color;
                    }
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            // 動画・キャプチャ・画像アップロード処理
            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file) setVideoSrc(URL.createObjectURL(file));
            };

            // --- 画像アップロード処理 ---
            const handleImageFiles = (e) => {
                const files = e.target.files;
                if (!files || files.length === 0) return;

                let imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
                if (imageFiles.length === 0) return;

                // ファイル名（数字）で昇順にソート
                imageFiles.sort((a, b) => {
                    const numA = parseInt(a.name.match(/\d+/)?.[0] || '0', 10);
                    const numB = parseInt(b.name.match(/\d+/)?.[0] || '0', 10);
                    return numA - numB;
                });

                // Promise.allを使用して順序を保証
                const promises = imageFiles.map((file) => {
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            resolve({
                                id: Date.now() + Math.random(),
                                originalImage: ev.target.result,
                                image: ev.target.result,
                                text: ``,
                                scale: 1, x: 0, y: 0, splitRatio: 0.5, annotations: []
                            });
                        };
                        reader.readAsDataURL(file);
                    });
                });

                Promise.all(promises).then((newSteps) => {
                    setSteps(prev => [...prev, ...newSteps]);
                    setHasUnsavedChanges(true);
                    setTimeout(() => {
                        if (stepsEndRef.current) {
                            stepsEndRef.current.scrollIntoView({ behavior: "smooth", block: "nearest" });
                        }
                    }, 100);
                });

                e.target.value = '';
            };

            const captureFrame = () => {
                if (videoRef.current && canvasRef.current) {
                    const video = videoRef.current;
                    const canvas = canvasRef.current;
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const dataUrl = canvas.toDataURL('image/jpeg');
                    const newStep = {
                        id: Date.now(),
                        originalImage: dataUrl,
                        image: dataUrl,
                        text: ``,
                        scale: 1, x: 0, y: 0, splitRatio: 0.5, annotations: []
                    };
                    setSteps([...steps, newStep]);
                    setHasUnsavedChanges(true);

                    // キャプチャ時のみ一番下にスクロール
                    setTimeout(() => {
                        if (stepsEndRef.current) {
                            stepsEndRef.current.scrollIntoView({ behavior: "smooth", block: "nearest" });
                        }
                    }, 100);
                }
            };

            const handleTextChange = (index, value) => {
                setSteps(prev => {
                    const next = [...prev];
                    next[index].text = value;
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const deleteStep = (index) => {
                setDeleteConfirm({ show: true, index });
            };

            const confirmDelete = () => {
                const index = deleteConfirm.index;
                setSteps(prev => prev.filter((_, i) => i !== index));
                if (activeStepIndex === index) setActiveStepIndex(null);
                setSelectedSteps(new Set());
                setHasUnsavedChanges(true);
                setDeleteConfirm({ show: false, index: null });
            };

            const cancelDelete = () => {
                setDeleteConfirm({ show: false, index: null });
            };

            const moveStep = (index, direction) => {
                if ((direction === -1 && index === 0) || (direction === 1 && index === steps.length - 1)) return;
                const newIndex = index + direction;
                setSteps(prev => {
                    const next = [...prev];
                    const temp = next[index];
                    next[index] = next[index + direction];
                    next[index + direction] = temp;
                    return next;
                });
                setHasUnsavedChanges(true);
                setTimeout(() => {
                    const el = scrollAreaRef.current?.querySelector(`[data-step-index="${newIndex}"]`);
                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 50);
            };

            const moveBulkSteps = (direction) => {
                if (selectedSteps.size === 0) return;
                const sortedIndices = [...selectedSteps].sort((a, b) => a - b);
                if (direction === -1 && sortedIndices[0] === 0) return;
                if (direction === 1 && sortedIndices[sortedIndices.length - 1] === steps.length - 1) return;
                setSteps(prev => {
                    const next = [...prev];
                    if (direction === -1) {
                        for (const idx of sortedIndices) {
                            const temp = next[idx]; next[idx] = next[idx - 1]; next[idx - 1] = temp;
                        }
                    } else {
                        for (const idx of [...sortedIndices].reverse()) {
                            const temp = next[idx]; next[idx] = next[idx + 1]; next[idx + 1] = temp;
                        }
                    }
                    return next;
                });
                setSelectedSteps(new Set(sortedIndices.map(i => i + direction)));
                setHasUnsavedChanges(true);
            };

            const toggleStepSelection = (index) => {
                setSelectedSteps(prev => {
                    const next = new Set(prev);
                    if (next.has(index)) next.delete(index); else next.add(index);
                    return next;
                });
            };

            const rotateImage = (index) => {
                const step = steps[index];
                const img = new Image();
                img.src = step.image;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.height;
                    canvas.height = img.width;
                    const ctx = canvas.getContext('2d');
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(90 * Math.PI / 180);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    const newDataUrl = canvas.toDataURL('image/jpeg');
                    setSteps(prev => {
                        const next = [...prev];
                        const curScale = next[index].scale || 1;
                        next[index].image = newDataUrl;
                        next[index].x = 0; next[index].y = 0; 
                        next[index].scale = curScale; 
                        return next;
                    });
                    setHasUnsavedChanges(true);
                };
            };

            const zoomImage = (index, delta) => {
                setSteps(prev => {
                    const next = [...prev];
                    let s = (next[index].scale || 1) + delta;
                    if (s < 0.5) s = 0.5; if (s > 5.0) s = 5.0;
                    next[index].scale = s;
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            const resetImage = (index) => {
                setSteps(prev => {
                    const next = [...prev];
                    if(next[index].originalImage) next[index].image = next[index].originalImage; 
                    next[index].scale = 1; next[index].x = 0; next[index].y = 0;
                    return next;
                });
                setHasUnsavedChanges(true);
            };

            // データ保存・読込
            const saveData = () => {
                if (steps.length === 0) return alert("データがありません");
                const data = JSON.stringify({ steps, fileName });
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${fileName.trim() || "作業書データ"}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                setHasUnsavedChanges(false);
            };

            const loadData = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        if (Array.isArray(data)) {
                            if (hasUnsavedChanges && steps.length > 0 && !confirm("上書きしますか？")) return;
                            const fixed = data.map(s => ({ ...s, originalImage: s.originalImage || s.image }));
                            setSteps(fixed.map(fixStepData));
                        } else if (data.steps) {
                            if (hasUnsavedChanges && steps.length > 0 && !confirm("上書きしますか？")) return;
                            const fixed = data.steps.map(s => ({ ...s, originalImage: s.originalImage || s.image }));
                            setSteps(fixed.map(fixStepData));
                            if(data.fileName) setFileName(data.fileName);
                        }
                        setHasUnsavedChanges(false);
                    } catch (err) { alert("読み込み失敗"); }
                };
                reader.readAsText(file);
                e.target.value = '';
            };

            const fixStepData = (step) => ({
                ...step,
                splitRatio: step.splitRatio || 0.5,
                annotations: (step.annotations || []).map(a => {
                    // 旧データ(size)があればrx,ryに変換する簡易ロジック
                    const baseSize = (a.size || 1.0) * 5;
                    return {
                        ...a,
                        rx: a.rx || baseSize,
                        ry: a.ry || baseSize,
                        rotation: a.rotation || 0,
                        length: a.length || 16,
                        strokeWidth: a.strokeWidth || 2,
                        // テキストラベル用のデフォルト値
                        text: a.type === 'text-label' ? (a.text || 'テキスト') : a.text,
                        fontSize: a.type === 'text-label' ? (a.fontSize || 14) : a.fontSize,
                        color: a.type === 'text-label' ? (a.color || 'white') : a.color,
                        // 番号スタンプ用のデフォルト値
                        number: a.type === 'number-stamp' ? (a.number || 1) : a.number,
                        stampSize: a.type === 'number-stamp' ? (a.stampSize || 6) : a.stampSize,
                    };
                })
            });

            return (
                <div className="h-full flex flex-col font-sans text-gray-800 bg-gray-50 overflow-hidden">
                    <header className="flex-shrink-0 flex items-center justify-between border-b bg-white px-6 py-3 shadow-sm z-50 print-hidden">
                        <div><h1 className="text-xl font-bold flex items-center gap-2 text-indigo-600"><FileVideo className="w-6 h-6" /> 作業書作成支援ツール</h1></div>
                        <div className="flex items-center gap-4">
                            <div className="flex items-center gap-2 bg-gray-100 rounded-lg p-1">
                                <span className="text-xs font-bold text-gray-500 ml-2">名:</span>
                                <input type="text" value={fileName} onChange={(e) => setFileName(e.target.value)} className="border rounded px-2 py-1 text-sm w-32 focus:outline-none" placeholder="作業書データ" />
                                <div className="h-5 w-px bg-gray-300 mx-1"></div>
                                <button onClick={saveData} disabled={steps.length === 0} className={`flex items-center gap-1 px-3 py-1.5 rounded text-sm transition-colors ${hasUnsavedChanges && steps.length > 0 ? "bg-indigo-100 text-indigo-700 font-bold" : "bg-white text-gray-700 hover:bg-gray-50"}`}><Save className="w-4 h-4" /> 保存{hasUnsavedChanges ? "*" : ""}</button>
                                <button onClick={() => jsonInputRef.current?.click()} className="flex items-center gap-1 px-3 py-1.5 bg-white text-gray-700 rounded text-sm hover:bg-gray-50"><Upload className="w-4 h-4" /> 読込</button>
                                <input type="file" accept=".json" ref={jsonInputRef} className="hidden" onChange={loadData} />
                            </div>
                            <button onClick={() => window.print()} className="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 text-sm shadow-md"><Printer className="w-4 h-4" /> 印刷 / PDF</button>
                        </div>
                    </header>

                    <div className="flex-1 flex overflow-hidden">
                        <div className="w-1/3 min-w-[320px] max-w-[480px] bg-white border-r p-4 overflow-y-auto print-hidden z-40 shadow-md">
                            <div className="sticky top-0 bg-white pb-4 z-10">
                                <h2 className="font-semibold mb-4 flex items-center gap-2 text-gray-700"><FileVideo className="w-5 h-5 text-indigo-500" /> ソース動画</h2>
                                {!videoSrc ? (
                                    <div onClick={() => fileInputRef.current?.click()} className="border-2 border-dashed border-gray-300 rounded-lg h-48 flex flex-col items-center justify-center cursor-pointer hover:bg-gray-50 transition-colors">
                                        <FileVideo className="w-10 h-10 text-gray-300 mb-2" /><p className="text-gray-500 font-medium text-sm">動画を選択</p>
                                    </div>
                                ) : (
                                    <div className="space-y-3">
                                        <div className="rounded-lg overflow-hidden bg-black aspect-video shadow-sm"><video ref={videoRef} src={videoSrc} controls className="w-full h-full object-contain" /></div>
                                        <div className="flex gap-2">
                                            <button onClick={captureFrame} className="flex-1 flex items-center justify-center gap-2 bg-indigo-600 text-white py-2 rounded-lg hover:bg-indigo-700 font-medium shadow-sm active:scale-95 transition-transform"><Camera className="w-5 h-5" /> キャプチャ</button>
                                            <button onClick={() => setVideoSrc(null)} className="px-3 py-2 bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200" title="動画を変更"><Trash2 className="w-5 h-5" /></button>
                                        </div>
                                    </div>
                                )}
                                <input type="file" accept="video/*" ref={fileInputRef} className="hidden" onChange={handleFileUpload} />
                                <canvas ref={canvasRef} className="hidden" />

                                <div className="mt-6 border-t pt-4">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2 text-gray-700"><FileImage className="w-5 h-5 text-indigo-500" /> 画像を追加</h3>
                                    <button onClick={() => imageInputRef.current?.click()} className="w-full border-2 border-dashed border-gray-300 rounded-lg h-24 flex flex-col items-center justify-center cursor-pointer hover:bg-gray-50 transition-colors text-gray-500 hover:text-indigo-500">
                                        <PlusCircle className="w-8 h-8 mb-1" /><span className="text-xs">画像を選択 または ドロップ</span>
                                    </button>
                                    <input type="file" accept="image/*" multiple ref={imageInputRef} className="hidden" onChange={handleImageFiles} />
                                </div>

                                <div className="mt-6 border-t pt-4">
                                    <h3 className="font-semibold mb-3 text-gray-700">編集ツール</h3>
                                    {activeStepIndex === null && <p className="text-xs text-gray-400 mb-2">右側のステップをクリックして選択</p>}
                                    <div className="space-y-2">
                                        <div className="flex gap-2">
                                            <button onClick={() => setAnnotationTool(annotationTool === 'circle' ? null : 'circle')} disabled={activeStepIndex === null} className={`flex-1 p-2 rounded text-sm ${annotationTool === 'circle' ? 'bg-red-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-100 border border-gray-200'} disabled:opacity-30`} title="丸"><Circle className="w-4 h-4 mx-auto" /></button>
                                            <button onClick={() => setAnnotationTool(annotationTool === 'arrow' ? null : 'arrow')} disabled={activeStepIndex === null} className={`flex-1 p-2 rounded text-sm ${annotationTool === 'arrow' ? 'bg-red-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-100 border border-gray-200'} disabled:opacity-30`} title="矢印"><ArrowRight className="w-4 h-4 mx-auto" /></button>
                                            <button onClick={() => selectedAnnotation && changeStrokeWidth(selectedAnnotation.stepIndex, selectedAnnotation.annotationId, 1)} disabled={!selectedAnnotation} className="flex-1 p-2 bg-white text-gray-600 hover:bg-indigo-50 rounded border border-gray-200 disabled:opacity-30 text-xs" title="太くする">太</button>
                                            <button onClick={() => selectedAnnotation && changeStrokeWidth(selectedAnnotation.stepIndex, selectedAnnotation.annotationId, -1)} disabled={!selectedAnnotation} className="flex-1 p-2 bg-white text-gray-600 hover:bg-indigo-50 rounded border border-gray-200 disabled:opacity-30 text-xs" title="細くする">細</button>
                                        </div>
                                        <div className="flex gap-2">
                                            <button onClick={() => setAnnotationTool(annotationTool === 'text-label' ? null : 'text-label')} disabled={activeStepIndex === null} className={`flex-1 p-2 rounded text-sm ${annotationTool === 'text-label' ? 'bg-red-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-100 border border-gray-200'} disabled:opacity-30`} title="テキスト"><Type className="w-4 h-4 mx-auto" /></button>
                                            <button onClick={() => setAnnotationTool(annotationTool === 'number-stamp' ? null : 'number-stamp')} disabled={activeStepIndex === null} className={`flex-1 p-2 rounded text-sm ${annotationTool === 'number-stamp' ? 'bg-red-500 text-white' : 'bg-white text-gray-600 hover:bg-gray-100 border border-gray-200'} disabled:opacity-30`} title="番号"><Hash className="w-4 h-4 mx-auto" /></button>
                                            <button onClick={() => selectedAnnotation && activeStepIndex !== null && steps[activeStepIndex]?.annotations?.find(a => a.id === selectedAnnotation?.annotationId)?.type === 'text-label' && changeTextLabelColor(selectedAnnotation.stepIndex, selectedAnnotation.annotationId, '#dc2626')} disabled={!selectedAnnotation || !(activeStepIndex !== null && steps[activeStepIndex]?.annotations?.find(a => a.id === selectedAnnotation?.annotationId)?.type === 'text-label')} className="flex-1 p-2 bg-white text-red-600 hover:bg-red-100 rounded border border-gray-200 disabled:opacity-30 text-xs" title="テキストラベルを赤文字にする">赤字</button>
                                            <button onClick={() => selectedAnnotation && deleteAnnotation(selectedAnnotation.stepIndex, selectedAnnotation.annotationId)} disabled={!selectedAnnotation} className="flex-1 p-2 bg-white text-red-600 hover:bg-red-50 rounded border border-gray-200 disabled:opacity-30" title="削除"><Trash2 className="w-4 h-4 mx-auto" /></button>
                                        </div>
                                        <div className="flex gap-2">
                                            <button onClick={() => activeStepIndex !== null && rotateImage(activeStepIndex)} disabled={activeStepIndex === null} className="flex-1 p-2 bg-white text-gray-600 hover:bg-indigo-50 rounded border border-gray-200 disabled:opacity-30" title="回転"><RotateCw className="w-4 h-4 mx-auto" /></button>
                                            <button onClick={() => activeStepIndex !== null && zoomImage(activeStepIndex, 0.1)} disabled={activeStepIndex === null} className="flex-1 p-2 bg-white text-gray-600 hover:bg-indigo-50 rounded border border-gray-200 disabled:opacity-30" title="拡大"><ZoomIn className="w-4 h-4 mx-auto" /></button>
                                            <button onClick={() => activeStepIndex !== null && zoomImage(activeStepIndex, -0.1)} disabled={activeStepIndex === null} className="flex-1 p-2 bg-white text-gray-600 hover:bg-indigo-50 rounded border border-gray-200 disabled:opacity-30" title="縮小"><ZoomOut className="w-4 h-4 mx-auto" /></button>
                                            <button onClick={() => activeStepIndex !== null && resetImage(activeStepIndex)} disabled={activeStepIndex === null} className="flex-1 p-2 bg-white text-gray-600 hover:bg-red-50 rounded border border-gray-200 disabled:opacity-30" title="リセット"><RefreshCcw className="w-4 h-4 mx-auto" /></button>
                                        </div>
                                    </div>
                                </div>

                                <div className="mt-6 border-t pt-4">
                                    <h3 className="font-semibold mb-3 text-gray-700">コンテンツ操作</h3>
                                    <div className="space-y-2">
                                        <button
                                            onClick={() => { setSelectionMode(m => !m); setSelectedSteps(new Set()); }}
                                            disabled={steps.length === 0}
                                            className={`w-full flex items-center justify-center gap-2 py-2 rounded-lg text-sm border font-medium transition-colors disabled:opacity-30 ${selectionMode ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'}`}
                                        >
                                            {selectionMode ? '選択を終了' : '複数選択'}
                                        </button>
                                        {selectionMode && (
                                            <div className="flex gap-2">
                                                <span className="flex items-center justify-center text-xs text-gray-500 bg-gray-50 rounded border border-gray-200 px-2 py-1 whitespace-nowrap">
                                                    {selectedSteps.size}件選択
                                                </span>
                                                <button onClick={() => moveBulkSteps(-1)} disabled={selectedSteps.size === 0} className="flex-1 flex items-center justify-center gap-1 py-2 bg-white border border-gray-300 text-gray-700 rounded-lg text-xs hover:bg-indigo-50 hover:text-indigo-600 disabled:opacity-30"><ArrowUp className="w-3 h-3" /> 上へ</button>
                                                <button onClick={() => moveBulkSteps(1)} disabled={selectedSteps.size === 0} className="flex-1 flex items-center justify-center gap-1 py-2 bg-white border border-gray-300 text-gray-700 rounded-lg text-xs hover:bg-indigo-50 hover:text-indigo-600 disabled:opacity-30"><ArrowDown className="w-3 h-3" /> 下へ</button>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>

                            <div className="mt-6 p-4 bg-blue-50 rounded-lg text-sm text-blue-800">
                                <p className="font-bold mb-1">使い方</p>
                                <ul className="list-decimal list-inside space-y-1 text-xs opacity-80">
                                    <li>動画を読み込み、再生位置で「キャプチャ」ボタンを押します。</li>
                                    <li>または「画像を追加」から写真などの画像ファイルを追加します。</li>
                                    <li>右側に作業項目が追加されます。ステップをクリックして選択します。</li>
                                    <li>編集ツールで、注釈追加や画像の編集ができます。</li>
                                    <li>注釈は4種類：矢印、丸、テキストラベル、番号スタンプ</li>
                                    <li>注釈はドラッグで移動、選択して変形、太さ変更が可能です。</li>
                                    <li>テキストや番号はダブルクリックで編集できます。</li>
                                    <li>テキストラベルを選択後、「赤字」ボタンで文字色を赤に変更できます。</li>
                                </ul>
                            </div>
                        </div>

                        <div className="flex-1 bg-gray-200 overflow-y-auto scroll-area custom-scrollbar" ref={scrollAreaRef} onClick={() => setSelectedAnnotation(null)}>
                            {/* A4プレビュー枠を外し、通常のリスト表示に戻す */}
                            <div className="w-full max-w-5xl mx-auto my-8 p-4 right-content transition-all">
                                <div className="flex items-center mb-6 pb-2 print-hidden border-b border-gray-300">
                                    <h2 className="font-semibold flex items-center gap-2 text-lg text-gray-700"><FileText className="w-5 h-5 text-indigo-500" /> 作成された作業項目 ({steps.length})</h2>
                                </div>

                                {steps.length === 0 ? (
                                    <div className="flex flex-col items-center justify-center h-64 text-gray-400 print-hidden"><p>ここに作業項目が追加されます</p></div>
                                ) : (
                                    <div className="space-y-6 print:space-y-0 print:block">
                                        {steps.map((step, index) => {
                                            return (
                                                <div key={step.id} data-step-index={index} className={`group relative flex gap-3 p-3 rounded-xl border transition-all bg-white step-item flex-row step-row ${activeStepIndex === index ? 'border-indigo-500 shadow-lg' : selectedSteps.has(index) ? 'border-blue-400 shadow-md bg-blue-50' : 'border-gray-300 hover:border-indigo-300'}`} onClick={() => setActiveStepIndex(index)}>
                                                    <div className="flex flex-col" style={{ width: '520px', flexShrink: 0 }}>
                                                        <div className="flex-shrink-0 step-image-mask relative cursor-move bg-gray-50 border border-gray-200" style={{ overflow: 'hidden', width: '520px', height: '255.13px' }} onMouseDown={(e) => handleImageMouseDown(index, e)}>
                                                            <div className="relative w-full h-full flex items-center justify-center" style={{overflow: 'visible'}}>
                                                                <img src={step.image} className="max-w-none transition-transform duration-75 ease-out select-none pointer-events-none" style={{ transform: `translate(${step.x || 0}px, ${step.y || 0}px) scale(${step.scale || 1})`, width: '100%' }} draggable="false" />
                                                                <div className="absolute top-2 left-2 bg-black/60 text-white text-xs px-2 py-1 rounded font-mono z-10 pointer-events-none shadow-sm">Step {index + 1}</div>
                                                                <svg className="absolute w-full h-full pointer-events-none z-20" style={{ pointerEvents: annotationTool || selectedAnnotation ? 'auto' : 'none', overflow: 'hidden', top: 0, left: 0 }} viewBox="0 0 100 100" preserveAspectRatio="none">
                                                                    <defs>
                                                                        <filter id="text-glow" x="-50%" y="-50%" width="200%" height="200%">
                                                                            <feGaussianBlur in="SourceAlpha" stdDeviation="0.5" result="blur"/>
                                                                            <feOffset in="blur" dx="0" dy="0" result="offsetBlur"/>
                                                                            <feFlood floodColor="black" floodOpacity="1" result="color"/>
                                                                            <feComposite in="color" in2="offsetBlur" operator="in" result="shadow"/>
                                                                            <feMerge>
                                                                                <feMergeNode in="shadow"/>
                                                                                <feMergeNode in="shadow"/>
                                                                                <feMergeNode in="shadow"/>
                                                                                <feMergeNode in="SourceGraphic"/>
                                                                            </feMerge>
                                                                        </filter>
                                                                    </defs>
                                                                    {(step.annotations || []).map((ann) => {
                                                                        const isSelected = selectedAnnotation && selectedAnnotation.stepIndex === index && selectedAnnotation.annotationId === ann.id;
                                                                        const strokeW = ann.strokeWidth || 2;
                                                                        const arrowLen = ann.length || 16;
                                                                        const rot = (ann.rotation || 0) * Math.PI / 180;
                                                                        
                                                                        let p1x, p1y, p2x, p2y;
                                                                        if (ann.type === 'arrow') {
                                                                            p1x = -arrowLen/2 * Math.cos(rot); p1y = -arrowLen/2 * Math.sin(rot);
                                                                            p2x = arrowLen/2 * Math.cos(rot); p2y = arrowLen/2 * Math.sin(rot);
                                                                        }

                                                                        return (
                                                            <g key={ann.id} transform={`translate(${ann.x}, ${ann.y})`} className="pointer-events-auto" onClick={(e) => { e.stopPropagation(); setSelectedAnnotation({stepIndex: index, annotationId: ann.id}); }} onDoubleClick={(e) => { e.stopPropagation(); if (ann.type === 'text-label' || ann.type === 'number-stamp') editAnnotationText(index, ann.id); }}>
                                                                                {/* ヒットエリア(透明な太い線/楕円) */}
                                                                                 {ann.type === 'arrow' && (
                                                                                     <line x1={p1x} y1={p1y} x2={p2x} y2={p2y} stroke="transparent" strokeWidth="20" />
                                                                                 )}
                                                                                 {ann.type === 'circle' && (
                                                                                     <ellipse cx="0" cy="0" rx={ann.rx} ry={ann.ry} stroke="transparent" strokeWidth="20" fill="none" />
                                                                                 )}
                                                                                 {ann.type === 'text-label' && (
                                                                                     <circle cx="0" cy="0" r={(ann.fontSize || 3) * 1.5} fill="transparent" />
                                                                                 )}
                                                                                 {ann.type === 'number-stamp' && (
                                                                                     <circle cx="0" cy="0" r={(ann.stampSize || 6) + 2} fill="transparent" />
                                                                                 )}

                                                                                {ann.type === 'arrow' && (
                                                                                    <>
                                                                                        <g>
                                                                                            <line x1={p1x} y1={p1y} x2={p2x - (2 + strokeW) * Math.cos(rot)} y2={p2y - (2 + strokeW) * Math.sin(rot)} stroke="#dc2626" strokeWidth={strokeW} strokeLinecap="round" />
                                                                                            {/* Arrow Head (Scales with stroke width) */}
                                                                                            <path d={`M ${p2x} ${p2y} L ${p2x - (6 + strokeW)*Math.cos(rot - 0.5)} ${p2y - (6 + strokeW)*Math.sin(rot - 0.5)} L ${p2x - (6 + strokeW)*Math.cos(rot + 0.5)} ${p2y - (6 + strokeW)*Math.sin(rot + 0.5)} Z`} fill="#dc2626" />
                                                                                        </g>
                                                                                        {isSelected && (
                                                                                            <>
                                                                                                <circle cx={p1x} cy={p1y} r="3" fill="#f59e0b" stroke="white" strokeWidth="1" className="cursor-move print-hidden" onMouseDown={(e) => handleHandleMouseDown(e, 'arrow-start', index, ann.id)} />
                                                                                                <circle cx={p2x} cy={p2y} r="3" fill="#f59e0b" stroke="white" strokeWidth="1" className="cursor-move print-hidden" onMouseDown={(e) => handleHandleMouseDown(e, 'arrow-end', index, ann.id)} />
                                                                                                <g transform={`translate(0, 10)`} className="print-hidden cursor-move" onMouseDown={(e) => handleHandleMouseDown(e, 'move', index, ann.id)}>
                                                                                                    <rect x="-10" y="-10" width="20" height="20" fill="transparent" />
                                                                                                </g>
                                                                                            </>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                                {ann.type === 'circle' && (
                                                                                    <>
                                                                                        <ellipse cx="0" cy="0" rx={ann.rx} ry={ann.ry} fill="none" stroke="#dc2626" strokeWidth={strokeW} />
                                                                                        {isSelected && (
                                                                                            <>
                                                                                                <rect x={-ann.rx} y={-ann.ry} width={ann.rx * 2} height={ann.ry * 2} fill="transparent" stroke="#3b82f6" strokeWidth="0.5" strokeDasharray="2 2" className="print-hidden" />
                                                                                                <circle cx={ann.rx} cy="0" r="3" fill="#3b82f6" stroke="white" strokeWidth="1" className="cursor-ew-resize print-hidden" onMouseDown={(e) => handleHandleMouseDown(e, 'resize-circle-w', index, ann.id)} />
                                                                                                <circle cx="0" cy={ann.ry} r="3" fill="#3b82f6" stroke="white" strokeWidth="1" className="cursor-ns-resize print-hidden" onMouseDown={(e) => handleHandleMouseDown(e, 'resize-circle-h', index, ann.id)} />
                                                                                                <g className="print-hidden cursor-move" onMouseDown={(e) => handleHandleMouseDown(e, 'move', index, ann.id)}>
                                                                                                    <circle cx="0" cy="0" r="5" fill="transparent" />
                                                                                                </g>
                                                                                            </>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                                {ann.type === 'text-label' && (
                                                                                    <>
                                                                                        {/* テキストラベル: 黒ブラー付きテキスト */}
                                                                                        <g>
                                                                                            {/* テキスト本体（黒ブラー効果） */}
                                                                                            <text
                                                                                                x="0"
                                                                                                y="0"
                                                                                                fontSize={ann.fontSize || 3}
                                                                                                fontWeight="bold"
                                                                                                fill={ann.color || 'white'}
                                                                                                textAnchor="middle"
                                                                                                dominantBaseline="middle"
                                                                                                filter="url(#text-glow)"
                                                                                            >
                                                                                                {ann.text || 'テキスト'}
                                                                                            </text>
                                                                                        </g>
                                                                                        {isSelected && (
                                                                                            <>
                                                                                                {/* 選択時のサークル */}
                                                                                                <circle
                                                                                                    cx="0"
                                                                                                    cy="0"
                                                                                                    r={(ann.fontSize || 3) * 1.5}
                                                                                                    fill="transparent"
                                                                                                    stroke="#3b82f6"
                                                                                                    strokeWidth="0.3"
                                                                                                    strokeDasharray="1 1"
                                                                                                    className="print-hidden"
                                                                                                />
                                                                                                {/* リサイズハンドル（下） */}
                                                                                                <circle
                                                                                                    cx="0"
                                                                                                    cy={(ann.fontSize || 3) * 1.5}
                                                                                                    r="2"
                                                                                                    fill="#3b82f6"
                                                                                                    stroke="white"
                                                                                                    strokeWidth="0.5"
                                                                                                    className="cursor-ns-resize print-hidden"
                                                                                                    onMouseDown={(e) => handleHandleMouseDown(e, 'resize-text-label', index, ann.id)}
                                                                                                />
                                                                                                {/* 移動ハンドル（中央） */}
                                                                                                <circle
                                                                                                    cx="0"
                                                                                                    cy="0"
                                                                                                    r={(ann.fontSize || 3) * 1.5}
                                                                                                    fill="transparent"
                                                                                                    className="print-hidden cursor-move"
                                                                                                    onMouseDown={(e) => handleHandleMouseDown(e, 'move', index, ann.id)}
                                                                                                />
                                                                                            </>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                                {ann.type === 'number-stamp' && (
                                                                                    <>
                                                                                        {/* 番号スタンプ: 円 + 番号 */}
                                                                                        <g>
                                                                                            <circle cx="0" cy="0" r={ann.stampSize || 6} fill="#ef4444" stroke="#991b1b" strokeWidth="0.5" />
                                                                                            <text x="0" y="0" fontSize={(ann.stampSize || 6) * 0.6} fontWeight="bold" fill="white" textAnchor="middle" dominantBaseline="middle">
                                                                                                {ann.number || 1}
                                                                                            </text>
                                                                                        </g>
                                                                                        {isSelected && (
                                                                                            <>
                                                                                                {/* 選択時のバウンディングボックス */}
                                                                                                <circle cx="0" cy="0" r={ann.stampSize || 6} fill="transparent" stroke="#3b82f6" strokeWidth="0.5" strokeDasharray="2 2" className="print-hidden" />
                                                                                                {/* リサイズハンドル（右） */}
                                                                                                <circle
                                                                                                    cx={ann.stampSize || 6}
                                                                                                    cy="0"
                                                                                                    r="2"
                                                                                                    fill="#3b82f6"
                                                                                                    stroke="white"
                                                                                                    strokeWidth="0.5"
                                                                                                    className="cursor-ew-resize print-hidden"
                                                                                                    onMouseDown={(e) => handleHandleMouseDown(e, 'resize-number-stamp', index, ann.id)}
                                                                                                />
                                                                                                {/* 移動ハンドル */}
                                                                                                <g className="print-hidden cursor-move" onMouseDown={(e) => handleHandleMouseDown(e, 'move', index, ann.id)}>
                                                                                                    <circle cx="0" cy="0" r="5" fill="transparent" />
                                                                                                </g>
                                                                                            </>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                            </g>
                                                                        );
                                                                    })}
                                                                </svg>
                                                            </div>
                                                            {annotationTool && <div className="absolute inset-0 cursor-crosshair z-20" onClick={(e) => { const containerRef = { current: e.currentTarget.parentElement }; addAnnotation(index, annotationTool, e.clientX, e.clientY, containerRef); }} />}
                                                        </div>
                                                    </div>

                                                    <div className="step-text-container" style={{ width: '330px', flexShrink: 0 }}>
                                                        <RichTextEditor
                                                            value={step.text}
                                                            onChange={(html) => handleTextChange(index, html)}
                                                            placeholder="作業の手順やポイントを入力..."
                                                            style={{ width: '330px', height: '255.13px' }}
                                                        />
                                                    </div>

                                                    {selectionMode && (
                                                        <div className="absolute -top-3 -left-3 z-40 print-hidden" onClick={(e) => e.stopPropagation()}>
                                                            <input type="checkbox" checked={selectedSteps.has(index)} onChange={() => toggleStepSelection(index)} className="w-5 h-5 cursor-pointer accent-indigo-600" />
                                                        </div>
                                                    )}
                                                    <div className="absolute -top-3 -right-3 flex gap-1 print-hidden z-40">
                                                        <button onClick={(e) => { e.stopPropagation(); moveStep(index, -1); }} disabled={index === 0} className="bg-white text-gray-500 hover:text-indigo-600 border shadow-sm p-1.5 rounded-md disabled:opacity-30" title="上へ移動"><ArrowUp className="w-4 h-4" /></button>
                                                        <button onClick={(e) => { e.stopPropagation(); moveStep(index, 1); }} disabled={index === steps.length - 1} className="bg-white text-gray-500 hover:text-indigo-600 border shadow-sm p-1.5 rounded-md disabled:opacity-30" title="下へ移動"><ArrowDown className="w-4 h-4" /></button>
                                                        <button onClick={(e) => { e.stopPropagation(); deleteStep(index); }} className="bg-white text-gray-400 hover:text-red-500 border shadow-sm p-1.5 rounded-md" title="削除"><Trash2 className="w-4 h-4" /></button>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                        <div ref={stepsEndRef} />
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    {deleteConfirm.show && (
                        <div className="fixed inset-0 flex items-center justify-center z-[9999] bg-black/40 print-hidden" onClick={cancelDelete}>
                            <div className="bg-white rounded-xl shadow-2xl p-6 max-w-xs w-full mx-4" onClick={(e) => e.stopPropagation()}>
                                <p className="text-center text-gray-800 font-semibold text-lg mb-6">本当に消しますか？</p>
                                <div className="flex gap-3 justify-center">
                                    <button onClick={confirmDelete} className="px-5 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 font-medium transition-colors">はい（削除）</button>
                                    <button autoFocus onClick={cancelDelete} className="px-5 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium transition-colors focus:ring-2 focus:ring-indigo-400 focus:outline-none">いいえ（キャンセル）</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
